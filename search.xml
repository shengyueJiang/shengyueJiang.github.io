<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>爬虫-XPath的使用</title>
      <link href="/2022/07/14/%E7%88%AC%E8%99%AB-XPATH%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/14/%E7%88%AC%E8%99%AB-XPATH%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>XPath是一种XML路径语言，它是一门在XML文档中查找信息的语言。</p><div class="table-container"><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从当前节点选取直接子节点</td></tr><tr><td>//</td><td>从当前节点选取子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table></div><h1 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h1><p>首先需要导入<strong>lxml</strong>库的<strong>etree</strong>模块，调用<strong>HTML</strong>类进行初始化，就能够构造一个<strong>XPath</strong>解析对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="comment">#根据响应构造实例化对象</span></span><br><span class="line">html = etree.HTML(resp.text)</span><br></pre></td></tr></table></figure><p>一般会使用<strong>//</strong>开头的<strong>XPath</strong>规划来选取符合要求的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选取所有节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//*&#x27;</span>)</span><br><span class="line"><span class="comment">#选取所有li节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//li&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述方法中提取出的都是<strong>Element</strong>对象的列表。</p><h1 id="父节点与子节点"><a href="#父节点与子节点" class="headerlink" title="父节点与子节点"></a>父节点与子节点</h1><p>通过<strong>/</strong>和<strong>//</strong>能够查找元素中的子节点或者子孙节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取li节点的直接子节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//li/a&#x27;</span>)</span><br><span class="line"><span class="comment">#获取li节点的全部子孙节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul//a&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述两条语句存在一定的不同，前者使用的语法会获取到直接子节点，而后者会获取到所有子孙<strong>a</strong>节点。</p><blockquote><p>/用于获取直接子节点，<strong>//</strong>用于获取子孙节点。</p></blockquote><p>通过<strong>..</strong>可以查找元素的父节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取父节点例</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//a[@href=&quot;114260.htm&quot;]/../../@class&#x27;</span>)</span><br><span class="line">result.xpath(<span class="string">&#x27;//a[@href=&quot;114260.htm&quot;]/parent::*/../@class&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述两条语句都能够获取父节点，表示查找文档中所有属性<strong>href</strong>为<strong>114260.htm</strong>的<strong>a</strong>标签的父节点的父节点的<strong>class</strong>属性值。</p><h1 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h1><h2 id="单个属性匹配"><a href="#单个属性匹配" class="headerlink" title="单个属性匹配"></a>单个属性匹配</h2><p>使用@可以进行属性过滤，下面的代码表示匹配<strong>href</strong>属性为<strong>”114260.htm”</strong>的<strong>a</strong>标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.xpath(<span class="string">&#x27;//a[@href=&quot;114260.htm&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h2><p>有些情况下，属性会有多个值，例如下面例子中的<strong>li</strong>存在连个属性值，分别是<strong>li</strong>和<strong>li-first</strong>，此时需要使用<strong>contains（）</strong>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text =<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;aaa&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br><span class="line">result = html.fromstring(text)</span><br><span class="line">result.xpath(<span class="string">&#x27;//a[contains(@href, &quot;link.html&quot;)]/text()&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>contains（）</strong>函数第一个参数为属性的名字，第二个参数传入参数的值，表示只要该属性的值包括该参数就符合要求。</p><h2 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.xpath(<span class="string">&#x27;//li[contains(@id, &quot;li&quot;) or @name=&quot;first&quot;]/a/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在有多个属性是，方括号中的表达式可以使用逻辑表达式代替。上述例表示文档中所有<strong>id</strong>属性包括<strong>li</strong>或者<strong>name</strong>属性为<strong>first</strong>的<strong>li</strong>标签。</p><blockquote><p>在上面的例子中，使用了字符串作为实例文档，此时不能使用上面实例引入中的方式构建对象。因为使用字符串时获取到的对象是lxml.etree._Element，而不是lxml.etree._ElementTree。</p></blockquote><h2 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]//li/a/@href&#x27;</span>)</span><br></pre></td></tr></table></figure><p>只需要在编码中加入<strong>@想要获取的属性名字</strong>编码即可，如上例所示可以获取到<strong>a</strong>标签的<strong>href</strong>属性。</p><h1 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先获取子节点然后再获取内容</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]//li/a/text()&#x27;</span>)</span><br><span class="line"><span class="comment">#获取全部子孙节点的内容</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]//li//text()&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述两种方式都能够获取到节点的内容，只需要在编码中加入<strong>text()</strong>编码即可。</p><h1 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只获取倒数第一个该元素</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[last()]/a/text()&#x27;</span>)</span><br><span class="line"><span class="comment">#只获取倒数第二个该元素</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[last()-1]/a/text()&#x27;</span>)</span><br><span class="line"><span class="comment">#只获取前四个元素</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[position()&lt;5]/a/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以通过在括号中传入索引的方式来控制取部分元素，需注意这部分的索引从1开始。</p><h1 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h1><p>XPath提供的节点轴是我们有更多的节点类型选择方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ancestor轴配合后部分的*可以获取第一个li节点的全部祖先</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//li[1]/ancestor::*&#x27;</span>)</span><br><span class="line"><span class="comment">#获取第一个li节点的全部祖先div</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//li[1]/ancestor::div&#x27;</span>)</span><br><span class="line"><span class="comment">#attribute轴获取a标签所有的属性值</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[1]/a/attribute::*&#x27;</span>)</span><br><span class="line"><span class="comment">#child轴获取所有直接子节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[1]/child::*/text()&#x27;</span>)</span><br><span class="line"><span class="comment">#descendant获取所有子孙节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[1]/descendant::*&#x27;</span>)</span><br><span class="line"><span class="comment">#dfollowing获取当前节点之后的所有节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[1]/following::*&#x27;</span>)</span><br><span class="line"><span class="comment">#following-sibling获取当前节点之后的所有同级节点</span></span><br><span class="line">result.xpath(<span class="string">&#x27;//ul[@class=&quot;boxItem_ar&quot;]/li[1]/following-sibling::*&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-JavaScript逆向辅助模拟方法</title>
      <link href="/2022/07/11/%E7%88%AC%E8%99%AB-JavaScript%E9%80%86%E5%90%91%E8%BE%85%E5%8A%A9%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/11/%E7%88%AC%E8%99%AB-JavaScript%E9%80%86%E5%90%91%E8%BE%85%E5%8A%A9%E6%A8%A1%E6%8B%9F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-requests库的使用</title>
      <link href="/2022/07/11/%E7%88%AC%E8%99%AB-requests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/11/%E7%88%AC%E8%99%AB-requests%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#能够测试请求的种类并返回请求头的url</span></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/get&#x27;</span></span><br><span class="line"><span class="comment">#定义数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;84&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#可以在参数中加入请求头和数据</span></span><br><span class="line">resp = requests.get(url=icon_url, headers=headers, params=data)</span><br><span class="line"><span class="comment">#对于结果可以直接抓换成json类型</span></span><br><span class="line"><span class="comment">#会转换为字典形式</span></span><br><span class="line">resp.json()</span><br><span class="line"><span class="comment">#读取str类型</span></span><br><span class="line">resp.text</span><br></pre></td></tr></table></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;84&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#发送post请求</span></span><br><span class="line">resp = requests.post(url, headers = headers, data = data)</span><br><span class="line">resp.json()</span><br></pre></td></tr></table></figure><p>此部分需要注意，两种请求的不同状态，gei请求的数据参数名称为params，post请求为data。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>得到的响应除了能够得到其内容之外，还能够获取很多其他的内容。包括状态码，响应头，Cookies等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取url</span></span><br><span class="line"><span class="built_in">print</span>(resp.url)</span><br><span class="line"><span class="comment"># 获取请求历史</span></span><br><span class="line"><span class="built_in">print</span>(resp.history)</span><br><span class="line"><span class="comment"># 获取请求头</span></span><br><span class="line"><span class="built_in">print</span>(resp.headers)</span><br><span class="line"><span class="comment"># 获取cookies</span></span><br><span class="line"><span class="built_in">print</span>(resp.cookies)</span><br><span class="line"><span class="comment"># 获取状态码</span></span><br><span class="line"><span class="built_in">print</span>(resp.status_code)</span><br></pre></td></tr></table></figure><p>状态码是用来判断请求状态的代码，requests提供了一个内置的状态码查询对象requests.codes。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit() <span class="keyword">if</span> <span class="keyword">not</span> resp.status_code == requests.codes.ok <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&quot;ok!&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码通过查询模块来判断是否能够正常访问，如果不能正常访问就退出。</p><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>网站需要上传文件时，先实例化file类，然后再发出请求，即可上传文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span> : <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">resp = requests.post(url, files=files)</span><br></pre></td></tr></table></figure><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>当获取到响应类时，可以查看响应的cookies</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取cookies</span></span><br><span class="line"><span class="built_in">print</span>(resp.cookies)</span><br></pre></td></tr></table></figure><p>可以直接在请求头中加入Cookie，然后发送请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="comment"># 抓包抓来的cookie</span></span><br><span class="line">   <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">resp = requests.get(zhihu_url, headers = headers)</span><br></pre></td></tr></table></figure><p>通过cookies参数也可以设置，但是需要构造RequestsCookieJar对象。</p><h2 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h2><p>维持同一个会话将不需要考虑cookies问题，能够一直维持一个会话发出请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line"><span class="comment">#第一次访问设置cookie</span></span><br><span class="line">session.get(<span class="string">&#x27;http://httpbin.org/cookies/set/number/123456789&#x27;</span>)</span><br><span class="line"><span class="comment">#第二次访问能够获取到cookie</span></span><br><span class="line">resp = session.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h2><p>我们可以通过设置参数的方式来跳过证书验证，在requests中提供了此参数verify,可以修改此参数为False来不检查证书，否则就会默认为True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(url, verify=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>当我们通过这种方式获取网页时，会出现警告。警告建议我们指定证书，可以通过捕获日志或者禁止警告的方式来屏蔽警告。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.captureWarnings(<span class="literal">True</span>)</span><br><span class="line">urllib3.disable_warnings()</span><br></pre></td></tr></table></figure><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxits = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span> : <span class="string">&quot;ip地址&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(url, proxies = proxits)</span><br></pre></td></tr></table></figure><p>代理ip可以直接在请求函数中设置。</p><h2 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(url, timeout=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>上述设置的超时时间是读取时间和连接时间的总和，如果要分别指定则可以传入一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(url, timeout=(<span class="number">1</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>上述元组两位置分别表示连接时间和读取时间。</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp = requests.get(url, auth = (username, password))</span><br><span class="line">resp = requests.get(url, auth = requests.auth.HTTPBasicAuth(username, password))</span><br></pre></td></tr></table></figure><p>上述两条语句都能够通过认证，分别是自带的身份认证和HTTPBasicAuth的类。</p><h2 id="PreparedRequest"><a href="#PreparedRequest" class="headerlink" title="PreparedRequest"></a>PreparedRequest</h2><p>在request中同样可以把请求表示为一个数据结构，然后通过session来发送。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = requests.session()</span><br><span class="line">req = requests.Request(<span class="string">&#x27;POST&#x27;</span>, url, data=data, headers=headers)</span><br><span class="line">prepped = s.prepare_request(req)</span><br><span class="line">resp = s.send(prepped)</span><br></pre></td></tr></table></figure><p>首先引入Request，然后构造Request对象，并且实例化一个session对象，然后将其转换为一个prepare_request对象，最后调用send方法发送即可。</p><p>使用上述方式发出请求，可以把请求当作对象来看待，就可以构建队列进行调度。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 请求库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-urllib库的使用</title>
      <link href="/2022/07/11/%E7%88%AC%E8%99%AB-urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/11/%E7%88%AC%E8%99%AB-urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>urllib</strong>是python内置的HTTP请求库，不需要额外安装。</p><p>它包含下面四个模块：</p><ul><li><p><strong>request</strong>：模拟发送请求</p></li><li><p><strong>error</strong>：异常处理模块</p></li><li><p><strong>parse</strong>： 工具模块，提供很多处理URL的方法</p></li><li><p><strong>robotparser</strong>：识别网站的robots.txt文件，判断可爬取内容</p></li></ul><h1 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h1><h2 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen()"></a>urlopen()</h2><p><strong>request</strong>模块提供了最基本的构造HTTP请求的方法，其可以模拟浏览器的一个请求发起过程，同时还有很多其他内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment">#向浏览器发出get请求</span></span><br><span class="line">resp = urllib.request.urlopen(url)</span><br><span class="line"><span class="comment">#返回网页内容</span></span><br><span class="line">resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#返回网页的头部信息</span></span><br><span class="line">resp.getheaders()</span><br><span class="line"><span class="comment">#返回状态码</span></span><br><span class="line">resp.status</span><br></pre></td></tr></table></figure><p>方法会返回一个<strong>HTTPResponse</strong>对象，主要包含<strong>read()</strong>等方法，以及<strong>reason,status</strong>等属性。</p><h3 id="data参数"><a href="#data参数" class="headerlink" title="data参数"></a>data参数</h3><p>该参数会将请求方式变为post，并且必须是字节流编码格式，需要转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将数据转换为字节流编码格式</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&#x27;word&#x27;</span>:<span class="string">&#x27;hello&#x27;</span>&#125;), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#以post方式传输</span></span><br><span class="line">resp = urllib.request.urlopen(url_test_request, data = data, timeout=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>首先使用<strong>urlencode（）</strong>将参数字典转换为字符串，然后再使用<strong>bytes（）</strong>转换为字节流编码，编码格式为’utf-8’。</p></blockquote><h3 id="timeout参数"><a href="#timeout参数" class="headerlink" title="timeout参数"></a>timeout参数</h3><p>设置超时时间，如果超过这个请求时间将会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&#x27;word&#x27;</span>:<span class="string">&#x27;hello&#x27;</span>&#125;), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    resp = urllib.request.urlopen(url_test_request, data = data, timeout=<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp.read())</span><br><span class="line"><span class="comment">#获取异常</span></span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment">#判断是否为超时异常</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason, socket.timeout):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;TIME OUT&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>当需要复杂的请求时，构造<strong>Request（）</strong>类可以满足很多其它的要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">urllib</span>.<span class="title">request</span>.<span class="title">Request</span> (<span class="params">url, data=<span class="literal">None</span>, headers=&#123;&#125;, origin_req_host=<span class="literal">None</span>, unverifiable=<span class="literal">False</span>, method=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>url</strong>：是必传参数，其他参数为可选参数。</p></li><li><p><strong>data</strong>：必须传递<strong>bytes</strong>类型参数，如果其为字典，可以使用<strong>urllib.parse</strong>模块中的<strong>urlencode（）</strong>模块。</p></li><li><p><strong>headers</strong>：字典，请求头，可以在构造时直接传进参数，也可以调用实例的<strong>add_header（）</strong>方法添加。</p></li><li><strong>origin_rerq_host</strong>：请求的host名称或者IP地址。</li><li><strong>unverifiable</strong>：表示这个请求是否是无法验证的，默认为False。</li><li><strong>menthod</strong>：表示请求使用的方法，如GET,POST,PUT等。 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义data</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;offset&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#定义请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#转换为字节码同时编码</span></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(data),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#实例化请求</span></span><br><span class="line">request = urllib.request.Request(url_movie, data = data, headers = headers, method = <span class="string">&#x27;POST&#x27;</span>) </span><br><span class="line">resp = urllib.request.urlopen(request)</span><br></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>当处理<strong>Cookies</strong>或者代理时，我们需要一些更复杂的请求，<strong>urllib</strong>中提供了<strong>Handler</strong>，其可以看作是一个处理器，可以解决很多问题。</p><p>在<strong>urllib.request</strong>模块中有很多类继承Handlerd的基类<strong>BaseHandler</strong>很多不同的事件，例如：</p><ul><li><strong>HTTPDefaultErrorHandler</strong>：用于处理HTTP响应错误，错误会抛出HTTPError类型的异常。 </li><li><strong>HTTPCookieProcessor</strong>：用于处理cokies。</li><li><strong>ProxyHandler</strong>：用于设置代理，默认代理为空。</li><li><strong>HTTPPasswordMgr</strong>：用于管理密码，维护用户名和密码的表。</li><li><strong>HTTPBasicAuthHandler</strong>：用于管理认证，可以解决认证问题。</li></ul><p>使用不同的Handler构造Opener然后使用open（）方法，既可以发起高级请求。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这里首先实例 <strong>HTTPBasicAuthHandler</strong> 对象，其参数是 <strong>HTTPPasswordMgrWithDefaultRealm</strong> 对象， 它利用 <strong>ad _password （）</strong>添加进去用户名和密码，这样就建立了一个处理验证的 <strong>Handler</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">auth_url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">username = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"><span class="comment">#配置Handler</span></span><br><span class="line">p = urllib.request.HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">p.add_password(<span class="literal">None</span>, auth_url,username, password)</span><br><span class="line">auth_handler = urllib.request.HTTPBasicAuthHandler(p)</span><br><span class="line"><span class="comment">#构建请求实例</span></span><br><span class="line">opener = urllib.request.build_opener(auth_handler)</span><br><span class="line"><span class="comment">#发送请求</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    resp = opener.<span class="built_in">open</span>(auth_url)</span><br><span class="line">    <span class="built_in">print</span>(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure><p>使用上述<strong>Handler</strong>构建相应的<strong>opener</strong>，然后发送请求即可成功请求。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>添加代理的过程也是构建openr的过程，首先创建代理字典，然后配置相关的请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">proxyDict = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://&#x27;</span>+<span class="string">&#x27;ip&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置Handler</span></span><br><span class="line">proxy_handler = rllib.request.ProxyHandler(proxyDict)</span><br><span class="line"><span class="comment">#构建请求实例</span></span><br><span class="line">opener = rllib.request.build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    resp = opener.<span class="built_in">open</span>(<span class="string">&#x27;&#x27;</span>, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br><span class="line"></span><br><span class="line">    opener.close()</span><br></pre></td></tr></table></figure><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 请求库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能数学基础</title>
      <link href="/2022/05/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p><img src="https://bkimg.cdn.bcebos.com/formula/1a5b804b84818fc98d198eefd0b2f636.svg" alt></p><p>导数（Derivative），也叫导函数值。又名<a href="https://baike.baidu.com/item/微商/11036713">微商</a>，是<a href="https://baike.baidu.com/item/微积分/6065">微积分</a>中的重要基础概念。当函数y=f（x）的<a href="https://baike.baidu.com/item/自变量/6895256">自变量</a>x在一点x0上产生一个增量Δx时，函数输出值的增量Δy与自变量增量Δx的比值在Δx趋于0时的<a href="https://baike.baidu.com/item/极限/3564509">极限</a>a如果存在，a即为在x0处的导数，记作f’（x0）或df（x0）/dx。</p><p>导数是函数的局部性质。一个函数在某一点的导数描述了这个函数在这一点附近的变化率。如果函数的自变量和取值都是实数的话，函数在某一点的导数就是该函数所代表的曲线在这一点上的<a href="https://baike.baidu.com/item/切线/674562">切线</a><a href="https://baike.baidu.com/item/斜率/4914111">斜率</a>。导数的本质是通过极限的概念对函数进行局部的线性逼近。例如在<a href="https://baike.baidu.com/item/运动学/650696">运动学</a>中，物体的<a href="https://baike.baidu.com/item/位移/823868">位移</a>对于时间的导数就是物体的<a href="https://baike.baidu.com/item/瞬时速度/972057">瞬时速度</a>。</p><p>不是所有的函数都有导数，一个函数也不一定在所有的点上都有导数。若某函数在某一点导数存在，则称其在这一点<a href="https://baike.baidu.com/item/可导/11034968">可导</a>，否则称为不可导。然而，可导的函数一定<a href="https://baike.baidu.com/item/连续/6532794">连续</a>；不连续的函数一定不可导。</p><p>对于可导的函数f(x)，x↦f’(x)也是一个函数，称作f(x)的<a href="https://baike.baidu.com/item/导函数/185399">导函数</a>（简称导数）。寻找已知的函数在某点的导数或其导函数的过程称为<a href="https://baike.baidu.com/item/求导/1063861">求导</a>。实质上，求导就是一个求极限的过程，导数的四则运算法则也来源于极限的四则运算法则。反之，已知导函数也可以反过来求原来的函数，即<a href="https://baike.baidu.com/item/不定积分/6082893">不定积分</a>。</p><p><a href="https://baike.baidu.com/item/微积分基本定理/10350012">微积分基本定理</a>说明了求原函数与积分是等价的。求导和积分是一对互逆的操作，它们都是微积分学中最为基础的概念。</p><h2 id="导数与函数的性质"><a href="#导数与函数的性质" class="headerlink" title="导数与函数的性质"></a>导数与函数的性质</h2><ul><li><p>导数与函数单调性的关系：</p><ul><li><p>若导数大于零，则单调递增；若导数小于零，则单调递减；导数等于零为函数<a href="https://baike.baidu.com/item/驻点/10207453"><strong>驻点</strong></a>，不一定为<a href="https://baike.baidu.com/item/极值点">极值点</a>。需代入驻点左右两边的数值求导数正负判断单调性。</p></li><li><p>若已知函数为递增函数，则导数大于等于零；若已知函数为递减函数，则导数小于等于零。</p><blockquote><p>如果函数的导函数在某一区间内恒大于零（或恒小于零），那么函数在这一区间内单调递增（或单调递减），这种区间也称为函数的单调区间。导函数等于零的点称为函数的驻点，在这类点上函数可能会取得极大值或极小值（即极值可疑点）。进一步判断则需要知道导函数在附近的符号。对于满足的一点，如果存在使得在之前区间上都大于等于零，而在之后区间上都小于等于零，那么是一个极大值点，反之则为极小值点。</p></blockquote></li></ul></li><li><p>极值定理：函数在其整个定义域内可能有许多极 大值或极小值，而且某个极大值不 一定大于某个极小值。函数的极值 通过其一阶和二阶导数来确定。对于一元可微函数f (x)，它在某点x0有极值的充分必要条件是f(x)在x0的某邻域上一阶可导，在x0处二阶可导，且f’(X0)=0，f”(x0)≠0，那么：</p><ul><li>若f”（x0）&lt;0，则f在x0取得极大值；</li><li>若f”（x0）&gt;0，则f在x0取得极小值。</li></ul></li><li><p>导数与函数凹凸性的关系：可导函数的凹凸性与其导数的单调性有关。如果函数的导函数在某个区间上单调递增，那么这个区间上函数是向下凹的，反之则是向上凸的。如果二阶导函数存在，也可以用它的正负性判断，如果在某个区间上恒大于零，则这个区间上函数是向下凹的，反之这个区间上函数是向上凸的。曲线的凹凸分界点称为曲线的<a href="https://baike.baidu.com/item/拐点">拐点</a>。</p></li></ul><h2 id="一元函数的泰勒展开"><a href="#一元函数的泰勒展开" class="headerlink" title="一元函数的泰勒展开"></a>一元函数的泰勒展开</h2><p>泰勒公式：泰勒公式，是一个用<a href="https://baike.baidu.com/item/函数/301912">函数</a>在某点的信息描述其附近取值的<a href="https://baike.baidu.com/item/公式/9991">公式</a>。如果函数满足一定的条件，泰勒公式可以用函数在某一点的各阶导数值做系数构建一个多项式来近似表达这个函数。</p><p><img src="https://bkimg.cdn.bcebos.com/formula/e50e20f00f3bfd4833b8155c66b0b4fa.svg" alt="https://bkimg.cdn.bcebos.com/formula/e50e20f00f3bfd4833b8155c66b0b4fa.svg"></p><blockquote><p>在机器学习中，当我们的目标函数比较复杂不便于计算极值的时候使用泰勒展开近似的表示函数来解决问题。梯度下降法就是把函数展开到一次位置来近似地代替目标函数，牛顿法是把函数展开到二次来替代。</p></blockquote><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><p><a href="https://baike.baidu.com/item/一阶导数">一阶导数</a>的导数称为<a href="https://baike.baidu.com/item/二阶导数">二阶导数</a>，二阶以上的<a href="https://baike.baidu.com/item/导数/579188">导数</a>可由<a href="https://baike.baidu.com/item/归纳法">归纳法</a>逐阶定义。二阶和二阶以上的导数统称为高阶导数。二阶导数的导数叫做<a href="https://baike.baidu.com/item/三阶导数">三阶导数</a>，三阶导数的导数叫做四阶导数…… . 一般地，n-1阶导数的导数叫做 n 阶导数，即</p><p><img src="https://bkimg.cdn.bcebos.com/formula/511c51924eab73aef6881fa2d6b34da7.svg" alt="img"></p><p>分别记作</p><p><img src="https://bkimg.cdn.bcebos.com/formula/d6a64c9c405ea0812bffb1b741acae49.svg" alt="img"></p><p>或者写为</p><p><img src="https://bkimg.cdn.bcebos.com/formula/562eef9328a9bec692717176219d5c9f.svg" alt="img"></p><h2 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h2><p>在数学中，一个多变量的<a href="https://baike.baidu.com/item/函数/301912">函数</a>的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定（相对于全导数，在其中所有变量都允许变化）。</p><h2 id="高阶偏导数"><a href="#高阶偏导数" class="headerlink" title="高阶偏导数"></a>高阶偏导数</h2><p>对于多元函数来说，若其一阶偏导数仍是关于每个自变量的函数，并且一阶偏导数对每个自变量的偏导数也存在，则说这个多元函数具有二阶偏导数。以此类推，有三阶偏导数，四阶偏导数等，我们把一阶以上的偏导数称为高阶偏导数。例如：</p><p><img src="https://bkimg.cdn.bcebos.com/formula/43252b6a21d0891169b4c6712b436778.svg" alt></p><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/30adcbef76094b363dacf79fa8cc7cd98d109d82?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt></p><p>梯度是把导数推广到多元的情况，对于一个多元函数如果自变量有N个，梯度就是一个向量是所有自变量的偏导数构成了梯度。例如：设三元函数</p><p><img src="https://bkimg.cdn.bcebos.com/formula/65e808373c04769b1278633beaf4b0cb.svg" alt="img"></p><p> 在空间区域G内具有一阶连续偏导数，点</p><p><img src="https://bkimg.cdn.bcebos.com/formula/035cf9d96959e34697a06e28a8c9d674.svg" alt="img"></p><p> 称向量</p><p><img src="https://bkimg.cdn.bcebos.com/formula/1037066c4cceac95d6050b5f800adb72.svg" alt="img"></p><p>为函数</p><p><img src="https://bkimg.cdn.bcebos.com/formula/65e808373c04769b1278633beaf4b0cb.svg" alt="img"></p><p> 在点P的梯度，记为</p><p><img src="https://bkimg.cdn.bcebos.com/formula/e4ee9d1cc8d5e915fffbad1b091508e3.svg" alt="img"></p><p> 或</p><p><img src="https://bkimg.cdn.bcebos.com/formula/e436ce9e970a621fd7ef18a659cf2d0d.svg" alt="img"></p><h2 id="多元函数的泰勒展开"><a href="#多元函数的泰勒展开" class="headerlink" title="多元函数的泰勒展开"></a>多元函数的泰勒展开</h2><ul><li>多元函数的泰勒展开公式:</li></ul><p><img src="https://ask.qcloudimg.com/raw/mkni6vrp9q.png?imageView2/2/w/1620" alt></p><ul><li>一元函数的泰勒展开公式:</li></ul><p><img src="https://bkimg.cdn.bcebos.com/formula/e50e20f00f3bfd4833b8155c66b0b4fa.svg" alt="https://bkimg.cdn.bcebos.com/formula/e50e20f00f3bfd4833b8155c66b0b4fa.svg"></p><blockquote><p>其中第二项代表了梯度，第三项代表了Hessian矩阵，这部分可以和一元函数的泰勒展开对比记忆。</p></blockquote><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><ul><li><p>向量的内积：把两个向量通过计算变成一个标量。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F1227%252Faed242afj00r4qi0q0016d200dp009xg00dp009x.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&amp;refer=http%3A%2F%2Fnimg.ws.126.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655026648&amp;t=82a0c503b28cebce426bc4193a16e61b" alt></p></li><li><p>向量的范数：1-范数是各个向量绝对值之和，2-范数表示向量的长度也就是模。</p><p><img src="https://img0.baidu.com/it/u=2937700484,687154185&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=458&amp;h=393" alt></p></li></ul><h2 id="雅克比矩阵"><a href="#雅克比矩阵" class="headerlink" title="雅克比矩阵"></a>雅克比矩阵</h2><ul><li>假设存在一个多维到多维的映射函数，它的雅克比矩阵就是每个因变量都和自变量存在一个映射函数，则其雅克比矩阵如下：</li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp8.qhimg.com%2Fdmsmty%2F350_200_%2Ft015acaff7d5f96a7e8.gif&amp;refer=http%3A%2F%2Fp8.qhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655028326&amp;t=3111578b7ad6751e25aeabf527b9a079" alt></p><ul><li>例如：</li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200409140530760.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMTQ2MzY5%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655028326&amp;t=59e64ab1038a9dde7f53dcde828b7d89" alt></p><h2 id="Hessian矩阵"><a href="#Hessian矩阵" class="headerlink" title="Hessian矩阵"></a>Hessian矩阵</h2><ul><li>假设存在一个多元函数，有多个自变量。其Hessian就是由所有的二阶偏导数构成的，如下所示：</li></ul><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp3.qhmsg.com%2Fdmsmty%2F726_483_%2Ft0119cfa7af8c10d223.jpg&amp;refer=http%3A%2F%2Fp3.qhmsg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655028537&amp;t=1e301e059edc7079229b7cd1aebd6c87" alt></p><h2 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h2><ul><li>使用二次型可以表达很复杂的函数，二次型的矩阵表示如下：</li></ul><p><img src="https://www.zhihu.com/equation?tex=X%5E%7BT%7DAX%3D+%28x_%7B1%7D%2Cx_%7B2%7D...x_%7Bn%7D%29++%5Cbegin%7Bbmatrix%7D+++++a_%7B11%7D%26+a_%7B12%7D%26+%5Ccdots++%26+a_%7B1n%7D+%5C%5C+++++a_%7B21%7D%26+a_%7B22%7D%26+%5Ccdots++%26+a_%7B2n%7D+%5C%5C+++++%5Cvdots+%26+%5Cvdots+%26+%5Cddots+%26+%5Cvdots+%5C%5C+++++a_%7Bm1%7D%26+a_%7Bm2%7D%26+%5Ccdots++%26+a_%7Bmn%7D+++%5Cend%7Bbmatrix%7D++%5Cbegin%7Bpmatrix%7Dx_%7B1%7D++%5C%5Cx_%7B2%7D++%5C%5C%5Cvdots++%5C%5Cx_%7Bn%7D++%5Cend%7Bpmatrix%7D+" alt></p><h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><p>特征值和特征向量（eigenvalue and eigenvector）数学概念。若σ是线性空间V的线性变换，σ对V中某非零向量x的作用是伸缩：σ（x）=aζ，则称x是σ的属于a的特征向量，a称为σ的特征值。</p><p>数学上，线性变换的特征向量（本征向量）是一个非简并的向量，其方向在该变换下不变。该向量在此变换下缩放的比例称为其<a href="https://baike.baidu.com/item/特征值/11034909">特征值</a>（<a href="https://baike.baidu.com/item/本征值/5123308">本征值</a>）。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20191104152620818.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI2MDEwMg%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655031640&amp;t=75a17e492d9f220e0b574429b6b03bbf" alt></p><h2 id="特征值分解与奇异值分解"><a href="#特征值分解与奇异值分解" class="headerlink" title="特征值分解与奇异值分解"></a>特征值分解与奇异值分解</h2><p>我们可以使用某种方法把一个矩阵化成一个正交阵和正交阵的逆以及一个对角矩阵，这种方法可以用来进行PCA降维。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210107205444955.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JibGluZ2JibGluZw%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655031675&amp;t=b672d3f41fd6a3e27607330de0b276c2" alt></p><h2 id="矩阵和向量的求导公式"><a href="#矩阵和向量的求导公式" class="headerlink" title="矩阵和向量的求导公式"></a>矩阵和向量的求导公式</h2><ul><li>两个向量做内积对x求梯度：</li></ul><p><img src="https://t12.baidu.com/it/u=4205562209,2015488108&amp;fm=173&amp;app=25&amp;f=JPG?w=111&amp;h=53&amp;s=1AA87023CD20EC030C7DC5DA0000C0B0" alt></p><ul><li>对二次型求梯度：</li></ul><p><img src="https://t11.baidu.com/it/u=1537876558,1693074049&amp;fm=173&amp;app=25&amp;f=JPG?w=196&amp;h=51&amp;s=1A287423C573E8325C7500DA0000C0B1" alt></p><ul><li><p>对二次型求Session矩阵：</p><p>​                                                                                                <strong>∇<em>xTAx</em>=(<em>A</em>+A</strong>T<em>)</em>x</p></li></ul><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="条件概率与贝叶斯公式"><a href="#条件概率与贝叶斯公式" class="headerlink" title="条件概率与贝叶斯公式"></a>条件概率与贝叶斯公式</h2><p>条件概率是指<a href="https://baike.baidu.com/item/事件/6129105">事件</a>A<strong>在事件B发生的条件下</strong>发生的概率。条件<a href="https://baike.baidu.com/item/概率">概率</a>表示为：P（A|B），读作“A<strong>在B发生的条件下</strong>发生的概率”。若只有两个事件A，B，那么</p><p><img src="https://bkimg.cdn.bcebos.com/formula/e30d3c07ebac8545498b8acac60f34e8.svg" alt></p><p><a href="https://baike.baidu.com/item/贝叶斯定理/1185949">贝叶斯定理</a>由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件<a href="https://baike.baidu.com/item/概率">概率</a>之间的关系，比如 P(A|B) 和 P(B|A)。按照乘法法则，可以立刻导出：P(A∩B) = P(A)<em>P(B|A)=P(B)</em>P(A|B)。如上公式也可变形为：P(A|B)=P(B|A)*P(A)/P(B)。</p><blockquote><p>在<a href="https://baike.baidu.com/item/贝叶斯统计/3431194">贝叶斯统计</a>推断中，不确定数量的先验概率分布是在考虑一些因素之前表达对这一数量的置信程度的概率分布。例如，先验概率分布可能代表在将来的选举中投票给特定政治家的选民相对比例的概率分布。未知的数量可以是模型的参数或者是潜在变量。</p><p>事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。</p><p>机器学习中经常使用一种叫做最大化后验概率的思想。</p></blockquote><h2 id="随机事件的独立性"><a href="#随机事件的独立性" class="headerlink" title="随机事件的独立性"></a>随机事件的独立性</h2><p>设A，B为随机事件，若同时发生的概率等于各自发生的概率的乘积，则A，B<strong>相互独立</strong>。</p><p>一般地，设A1，A2，…，An是n(n≥2) 个事件，如果对于其中任意2个，任意3个，…，任意n个事件的积事件的概率，都等于各事件概率之积，则称A1，A2，…，An<strong>相互独立</strong>。</p><h2 id="数学期望与方差"><a href="#数学期望与方差" class="headerlink" title="数学期望与方差"></a>数学期望与方差</h2><p>在<a href="https://baike.baidu.com/item/概率论">概率论</a>和统计学中，数学期望(mathematic expectation  )（或<a href="https://baike.baidu.com/item/均值/5922988">均值</a>，亦简称期望）是试验中每次可能结果的<a href="https://baike.baidu.com/item/概率/828845">概率</a>乘以其结果的总和，是最基本的<a href="https://baike.baidu.com/item/数学/107037">数学</a>特征之一。<strong>它反映随机变量平均取值的大小。</strong></p><p>需要注意的是，期望值并不一定等同于常识中的“期望”——“期望值”也许与每一个结果都不相等。期望值是该变量输出值的<a href="https://baike.baidu.com/item/平均数/11031224">平均数</a>。期望值并不一定包含于变量的输出值集合里。</p><p>方差是在概率论和统计方差衡量<a href="https://baike.baidu.com/item/随机变量/828980">随机变量</a>或一组数据时离散程度的度量。概率论中方差用来度量<a href="https://baike.baidu.com/item/随机变量/828980">随机变量</a>和其<a href="https://baike.baidu.com/item/数学期望/5362790">数学期望</a>（即<a href="https://baike.baidu.com/item/均值/5922988">均值</a>）之间的偏离程度。统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的<a href="https://baike.baidu.com/item/平均数/11031224">平均数</a>。在许多实际问题中，研究方差即偏离程度有着重要意义。</p><p>方差是衡量源数据和期望值相差的度量值。</p><blockquote><p><strong>数学期望反映了随机变量取值的平均水平，方差反映了随机变量取值与其均值的偏离水平</strong></p></blockquote><h2 id="常用的概率分布"><a href="#常用的概率分布" class="headerlink" title="常用的概率分布"></a>常用的概率分布</h2><ul><li><p>正态分布</p><p>正态曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为<a href="https://baike.baidu.com/item/钟形曲线/7736826">钟形曲线</a>。</p><p>若<a href="https://baike.baidu.com/item/随机变量/828980">随机变量</a>X服从一个<a href="https://baike.baidu.com/item/数学期望/5362790">数学期望</a>为μ、<a href="https://baike.baidu.com/item/方差/3108412">方差</a>为σ2的正态分布，记为N(μ，σ2)。其<a href="https://baike.baidu.com/item/概率密度函数/5021996">概率密度函数</a>为正态分布的<a href="https://baike.baidu.com/item/期望值/8664642">期望值</a>μ决定了其位置，其<a href="https://baike.baidu.com/item/标准差/1415772">标准差</a>σ决定了分布的幅度。当μ = 0,σ = 1时的正态分布是<a href="https://baike.baidu.com/item/标准正态分布">标准正态分布</a>。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%3A%2F%2Fdingyue.ws.126.net%2F2020%2F1111%2F0f22b210j00qjm13j0007d200bh0059g00it008l.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&amp;refer=http%3A%2F%2Fnimg.ws.126.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655106430&amp;t=6a73f12c0a5dcde133654477ff35685f" alt></p></li><li><p>均匀分布</p><p>在<a href="https://baike.baidu.com/item/概率论/829122">概率论</a>和<a href="https://baike.baidu.com/item/统计学/1175">统计学</a>中，均匀分布也叫矩形分布，它是对称概率分布，在相同长度间隔的分布概率是等可能的。 均匀分布由两个参数a和b定义，它们是数轴上的最小值和最大值，通常缩写为U（a，b）。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F417%2F3ef7a56ea91c082a5acdd152810ca469.png&amp;refer=http%3A%2F%2Fwww.pianshen.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655106572&amp;t=3608d0738487dc9c96b549d9805b4560" alt></p></li></ul><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>能够描述多个维度的变量的相关程度，定义如下：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1436741%2F202005%2F1436741-20200511155710830-974926947.png&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1655107026&amp;t=5faf9b8c7be960c9eb573139b8c523d4" alt></p><h2 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h2><p>最大似然估计(maximum likelihood estimation, MLE)一种重要而普遍的求估计量的方法。<a href="https://baike.baidu.com/item/最大似然法/6705415">最大似然法</a>明确地使用概率模型，其目标是寻找能够以较高概率产生观察数据的系统发生树。最大似然法是一类完全基于<a href="https://baike.baidu.com/item/统计/221142">统计</a>的系统发生树重建方法的代表。</p><blockquote><p>根据我们的抽样来观察推断真实全集合上的概率，求解概率密度函数未知的参数。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 天池学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-BeautifulSoup的使用</title>
      <link href="/2022/03/06/%E7%88%AC%E8%99%AB-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/06/%E7%88%AC%E8%99%AB-BeautifulSoup%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>Beautiful Soup</strong>是Python的一个<strong>HTML</strong>或<strong>XML</strong>的解析库，可以用它来方便的从网页中提取数据。</p><h1 id="基本用法与解析器"><a href="#基本用法与解析器" class="headerlink" title="基本用法与解析器"></a>基本用法与解析器</h1><p>首先需要构造一个<strong>beautifulsoup</strong>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;lxml&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述语句中，首先需要传入需要解析的内容，后者传入的是使用的解析器。</p><p>解析器是<strong>BeautIfulSoup</strong>在解析时的依赖对象。其支持的解析器有以下几种：</p><div class="table-container"><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(html, ‘html.parse’)</td><td>执行速度适中，文档容错能力强</td><td>某些版本容错能力差</td></tr><tr><td>lxml HTML解析器</td><td>BeautifulSoup(html, ‘lxml’)</td><td>速度快，文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml XML解析器</td><td>BeautifulSoup(html, ‘xml’)</td><td>速度快，唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(html, “html5lib”)</td><td>容错性最好，以浏览器的方式解析文档、生成HTML5格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table></div><p>构建了基本对象后，就可以使用相应的方法进行解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把要解析的字符串以标准格式输出</span></span><br><span class="line">soup.prettify()</span><br><span class="line"><span class="comment"># 输出固定节点的文本内容</span></span><br><span class="line">soup.title.string</span><br></pre></td></tr></table></figure><h1 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h1><p>直接调用节点的名称可以选择节点元素，再调用<strong>string</strong>属性就可以的到节点内的文本了，这种方式非常快。</p><h2 id="获取节点内容"><a href="#获取节点内容" class="headerlink" title="获取节点内容"></a>获取节点内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选择节点元素然后调用string</span></span><br><span class="line">soup.title.string</span><br><span class="line"><span class="comment">#调用节点然后提取name</span></span><br><span class="line">soup.title.name</span><br></pre></td></tr></table></figure><h2 id="获取节点属性"><a href="#获取节点属性" class="headerlink" title="获取节点属性"></a>获取节点属性</h2><p>获取节点属性可以调用节点的attrs属性，若不指定任何的属性会获得一个字典，也可以指定属性名字获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取节点p的所有属性</span></span><br><span class="line">soup.p.attrs</span><br><span class="line"><span class="comment">#获取节点p的class属性值</span></span><br><span class="line">soup.p.attrs[<span class="string">&#x27;class&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="获取关联节点"><a href="#获取关联节点" class="headerlink" title="获取关联节点"></a>获取关联节点</h2><p>使用节点的不同属性可以获取节点的关联属性，包括子节点，父节点等。</p><p>获取节点的子节点以及子孙节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取节点的所有直接子节点</span></span><br><span class="line">soup.ol.contents</span><br><span class="line"><span class="comment">#获取节点的所有直接子节点，返回的类型是生成器类型。</span></span><br><span class="line">soup.ol.children</span><br><span class="line"><span class="comment">#返回所有的子孙节点</span></span><br><span class="line">soup.ol.descendants</span><br></pre></td></tr></table></figure><p>获取节点的父节点和祖先节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取p节点的父节点</span></span><br><span class="line">soup.p.parent</span><br><span class="line"><span class="comment">#获取p节点的祖先节点</span></span><br><span class="line">soup.p.parents</span><br></pre></td></tr></table></figure><p>获取节点的兄弟节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取p节点的前一个兄弟节点</span></span><br><span class="line">soup.p.prev_sibling</span><br><span class="line"><span class="comment"># 获取p节点的后一个兄弟节点</span></span><br><span class="line">soup.p.next_sibling</span><br></pre></td></tr></table></figure><p>获取节点的前后节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取节点的前一个元素</span></span><br><span class="line">soup.head.previous_element</span><br><span class="line"><span class="comment"># 获取节点的后一个元素</span></span><br><span class="line">soup.head.next_element</span><br></pre></td></tr></table></figure><p>与 .next_sibling .previous_sibling 不同，它并不是针对于兄弟节点，而是在所有节点。此处的节点不分层次，而是针对所有节点 。通过 .next_elements 和 .previous_elements 的迭代器就可以向前或向后访问文档的解析内容。</p><h1 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h1><p>方法选择器与节点选择器不同，此方法可以通过不同的属性或文本来搜寻符合条件的元素，它的功能十分强大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_all(name, attrs, recursive, text, **kwargs)</span><br></pre></td></tr></table></figure><p>上述代码表示方法选择器的<strong>API</strong>，<strong>name</strong>表示要查找的节点的名字，<strong>attrs</strong>表示查找的节点满足的属性条件，<strong>text</strong>能够根据不同的文本要求匹配节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有li节点</span></span><br><span class="line">soup.find_all(name=<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="comment"># 查找所有class为title的span节点</span></span><br><span class="line">soup.find_all(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">soup.find_all(<span class="string">&#x27;span&#x27;</span>, attrs = &#123;<span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;title&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 匹配节点的文本</span></span><br><span class="line">soup.find_all(text = re.<span class="built_in">compile</span>(<span class="string">&#x27;肖申克&#x27;</span>))</span><br></pre></td></tr></table></figure><p>上述方法选择器能够选择文档中所有的节点，但是还有很多其它的方法可以匹配不同的节点。</p><div class="table-container"><table><thead><tr><th>方法名称</th><th>作用范围</th></tr></thead><tbody><tr><td>find_all（）</td><td>返回文档中所有匹配的内容</td></tr><tr><td>find（）</td><td>返回第一个匹配到的内容</td></tr><tr><td>find_parents（）</td><td>返回节点的所有祖先节点</td></tr><tr><td>find_parent（）</td><td>返回直接父节点</td></tr><tr><td>find_previous_siblings（）</td><td>返回前面所有的兄弟节点</td></tr><tr><td>find_previous_silbing（）</td><td>返回前面第一个兄弟节点</td></tr><tr><td>find_next_siblings（）</td><td>返回后边的所有兄弟节点</td></tr><tr><td>find_next_silbing（）</td><td>返回后边第一个兄弟节点</td></tr><tr><td>find_all_next（）</td><td>返回节点后所有符合条件的节点</td></tr><tr><td>find_next（）</td><td>返回节点后第一个满足条件的节点</td></tr><tr><td>find_all_previous（）</td><td>返回节点前所有满足条件的节点</td></tr><tr><td>find_previous（）</td><td>返回节点前第一个满足条件的节点</td></tr></tbody></table></div><h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><p><strong>bs</strong>提供了与<strong>CSS</strong>类似的选择语法，使用<strong>CSS</strong>选择器时，需要使用<strong>select()</strong>方法，传入下相应的<strong>CSS</strong>选择器即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">&#x27;.panel .panel-heading&#x27;</span>)</span><br><span class="line">soup.select(<span class="string">&#x27;ul li&#x27;</span>)</span><br><span class="line">soup.select(<span class="string">&#x27;#list-2 .element&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述三行代码就是用了CSS选择器的语法，分别表示筛选类名为panel或.panel-heading的元素，筛选ul中的li元素，筛选id为list-2或者类名为element的元素。</p><p>除此之外，除了上述的string属性，该方法还可以使用get_text()来获取文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li.get_text()</span><br><span class="line">li.string</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-正则表达式</title>
      <link href="/2022/02/20/%E7%88%AC%E8%99%AB-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/02/20/%E7%88%AC%E8%99%AB-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>python的re库提供了整个正则表达式的实现，利用这个库，可以在python中使用正则表达式。</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><strong>元字符：具有固定含义的特殊符号</strong></p><p>常用元字符（每一个元字符默认只匹配一个字符）：</p><ul><li><strong>.</strong> ：匹配除了换行符以外的字符</li><li><strong>\w</strong> : 匹配字母，数字，下划线</li><li><strong>\s</strong> : 匹配任意的空白符</li><li><strong>\d</strong> : 匹配任意数字</li><li><strong>\n</strong> : 匹配换行符</li><li><strong>\t</strong> : 匹配制表符</li><li><strong>^</strong> :  匹配字符串的开始</li><li><strong>$</strong> : 匹配字符串的结尾</li><li><strong>\W</strong> : 匹配非字母，数字，下划线</li><li><strong>\S</strong> : 匹配非任意的空白符</li><li><strong>\D</strong> : 匹配非任意数字</li><li><strong>a|b</strong> : 匹配字符a或者字符b</li><li><strong>( )</strong>  : 匹配括号内的表达式，也表示一个组</li><li><strong>[ ]</strong> ：匹配字符组中的字符</li><li><strong>[ ^] </strong> ：匹配除了字符组中的字符</li></ul><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><ul><li><strong>*</strong> :  可以重复出现零次或者很多次</li><li><strong>+</strong> : 可以重复出现一次或者很多次</li><li><strong>？</strong> : 可以重复出现零次或者一次</li><li>{n} : 重复n次</li><li>{n,} : 重复n次或更多次</li><li>{n,m} : 重复n次到m次</li></ul><h2 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h2><ul><li><strong>.*</strong> ：贪婪匹配</li><li><strong>.*？</strong> ：惰性匹配</li></ul><p>.*表示会匹配尽可能多的字符.*?表示尽可能的少匹配字符。</p><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><h2 id="re-match"><a href="#re-match" class="headerlink" title="re.match( )"></a><strong>re.match( )</strong></h2><p>尝试从字符串的开头匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回None。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>content = <span class="string">&#x27;My phone number is 13878787878&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = re.match(<span class="string">&#x27;.*?(\d&#123;11&#125;)&#x27;</span>, content)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="string">&#x27;&lt;class re.Match&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>上述方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串。返回的对象是<strong>re.Match</strong>，该对象有两个常用的方法，<strong>group（）</strong>可以输出匹配到的内容，与此同时也可以在正则表达式中分组，使用该方法指定分组输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>content = <span class="string">&#x27;My phone number is 13878787878&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = re.match(<span class="string">&#x27;.*?(\d&#123;11&#125;)&#x27;</span>, content)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(result.group(<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;My phone number is 13878787878&#x27;</span></span><br><span class="line"><span class="string">&#x27;13878787878&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>span()</strong>能够输出匹配内容的位置信息，是一个元组，分别表示开始位置和结束位置，也可以传入组数，输出该组的字符位置。</p><ul><li><strong>re.findall( )</strong> : 匹配字符串中所有符合正则表达式的字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>number = re.findall(<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;my number is :12557169485&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(number)</span><br><span class="line"><span class="string">&#x27;12557169485&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>re.finditer( )</strong>:匹配字符串中所有的内容，返回一个迭代器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>number = re.finditer(<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;my number is :12557169485,5454679185&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [i.group() <span class="keyword">for</span> i <span class="keyword">in</span> number]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(l)</span><br><span class="line"><span class="string">&#x27;12557169485&#x27;</span>,<span class="string">&#x27;5454679185&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>re.search( )</strong>:找到一个结果就返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = re.search(<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;my number is :12557169485,5454679185&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.group())</span><br><span class="line"><span class="string">&#x27;12557169485&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>re.comple( )</strong>:预加载正则表达式，以便后边能够使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = obj.finditer(<span class="string">&#x27;my number is :12557169485,5454679185&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的python-字典和集合</title>
      <link href="/2022/02/10/%E6%B5%81%E7%95%85%E7%9A%84python-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2022/02/10/%E6%B5%81%E7%95%85%E7%9A%84python-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h1><h2 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h2><p>标准库中的所有映射类型都是利用dict来实现的，因为它们都只有<em>可散列</em>的数据类型才能作为映射中的键（只有键有这个要求）。</p><blockquote><p>可散列的数据类型：</p><p>“如果一个对象是可散列的，那么在这个对象的<a href="https://so.csdn.net/so/search?q=生命周期&amp;spm=1001.2101.3001.7020">生命周期</a>中，它的散列值是不变的，而且这个对象需要实现 <strong><strong>hash</strong>()</strong> 方法。另外可散列对象还要有 <strong><strong>eq</strong>()</strong> 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的…”、</p><p>原子不可变数据类型（str、bytes和数值类型）都是可散列类型，frozenset也是可散列的，因为根据其定义，frozenset里只能容纳可散列类型。对于元组，只有当一个元组包含的<strong>所有元素</strong>都是<strong>可散列</strong>类型的情况下，它才是可散列的。</p><p>一般来讲，用户自定义的类型的对象都是可散列的，散列值就是它们的id()函数的返回值，所以所有这些对象在比较的时候都是不相等的。如果一个对象实现了<strong>eq</strong>方法，并且在方法中用到了这个对象的内部状态的话（重写的eq方法可能比较的是对象中成员变量的值而不是id函数返回的内存地址），那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。</p></blockquote><p>因为这种可散列的性质，所以字典有很多种定义方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>,<span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>,<span class="string">&#x27;one&#x27;</span>: <span class="number">3</span> &#125;</span><br><span class="line">c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;one&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">zip</span>([(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>,<span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>,<span class="string">&#x27;one&#x27;</span>: <span class="number">3</span> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意：元组不一定是可散列的类型，只有当元组内的所有数据都是可散列的类型时，元组才是可散列的数据类型。</p></blockquote><h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流畅的Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas笔记(二)</title>
      <link href="/2022/01/16/Pandas%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
      <url>/2022/01/16/Pandas%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="单级索引"><a href="#单级索引" class="headerlink" title="单级索引"></a>单级索引</h2><h3 id="loc方法"><a href="#loc方法" class="headerlink" title="loc方法"></a>loc方法</h3><p><strong>此方法表示标签索引，会根据传递的标签获取值</strong></p><blockquote><p>n,m代表数字编号</p></blockquote><ul><li><p>单行索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[n]</span><br></pre></td></tr></table></figure></li><li><p>多行索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[[n,m]]</span><br></pre></td></tr></table></figure><p><strong>当只获取两行时使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[n:m]</span><br></pre></td></tr></table></figure><p><strong>当需要获取切片时使用，注意在pandas的切片中两侧都是闭合的</strong></p></li><li><p>单列索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:,&#x27;Height&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>多列索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:,[&#x27;Height&#x27;,&#x27;Math&#x27;]]</span><br></pre></td></tr></table></figure><p><strong>当只获取两列时使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:,&#x27;Height&#x27;:&#x27;Math&#x27;]</span><br></pre></td></tr></table></figure><p><strong>当需要获取列切片时使用，两侧都是闭合的</strong></p></li><li><p>联合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[1102:2401:3,&#x27;Height&#x27;:&#x27;Math&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>函数式索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="keyword">lambda</span> x:x[<span class="string">&#x27;Gender&#x27;</span>]==<span class="string">&#x27;M&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>使用匿名函数来控制索引</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1101</span>,<span class="number">1103</span>]</span><br><span class="line">df.loc[f]</span><br></pre></td></tr></table></figure><p><strong>这里的例子表示，loc中能够传入函数，并且函数的输入值是整张表，输出为标量、切片、合法列表（元素出现在索引中）、合法索引，都可以运行</strong></p></li><li><p>布尔索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[df[&#x27;Address&#x27;].isin([&#x27;street_7&#x27;,&#x27;street_4&#x27;])].head()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[[True if i[-1]==&#x27;4&#x27; or i[-1]==&#x27;7&#x27; else False for i in df[&#x27;Address&#x27;].values]].head()</span><br></pre></td></tr></table></figure><p><strong>本质上说，loc中能传入的只有布尔列表和索引子集构成的列表，只要把握这个原则就很容易理解上面那些操作</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas笔记(一)</title>
      <link href="/2022/01/14/Pandas%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2022/01/14/Pandas%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="CSV文件读取"><a href="#CSV文件读取" class="headerlink" title="CSV文件读取"></a>CSV文件读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(path)</span><br></pre></td></tr></table></figure><h3 id="自定义索引"><a href="#自定义索引" class="headerlink" title="自定义索引"></a>自定义索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df=pd.read_csv(path,index_col=[<span class="string">&#x27;ID&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>index_col会指定文件中的某一列作为索引建立DataFrame，适用于文件中已经有自带的索引的文件。</p></blockquote><h3 id="查看每一列的dtype"><a href="#查看每一列的dtype" class="headerlink" title="查看每一列的dtype"></a>查看每一列的dtype</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#转换salary为float类型</span></span><br><span class="line">df=pd.read_csv(path,dtype=&#123;<span class="string">&#x27;Salary&#x27;</span>:np.float64&#125;)</span><br></pre></td></tr></table></figure><h3 id="更改文件列标签"><a href="#更改文件列标签" class="headerlink" title="更改文件列标签"></a>更改文件列标签</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df=pd.read_csv(path,names=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>在读取文件的时候，可以自定义列名，但是原来的列名还是会存在，可以用<code>header</code>来删除。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df=pd.read_csv(path,names=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>],header=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><blockquote><p>header参数为0时，会不读取列标签。</p></blockquote><h3 id="跳过指定行数"><a href="#跳过指定行数" class="headerlink" title="跳过指定行数"></a>跳过指定行数</h3><p><code>skiprows</code>参数表示跳过指定的行数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df=pd.read_csv(path,skiprows=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><blockquote><p>Pandas Series 类似表格中的一个列（column），类似于一维数组，可以保存任何数据类型，Series 由索引（index）和列组成。</p></blockquote><h3 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.Series( data, index, dtype, name, copy)</span><br></pre></td></tr></table></figure><blockquote><p><strong>data</strong>：一组数据(ndarray 类型)。</p><p><strong>index</strong>：数据索引标签，如果不指定，默认从 0 开始。</p><p><strong>dtype</strong>：数据类型，默认会自己判断。</p><p><strong>name</strong>：设置名称。</p><p><strong>copy</strong>：拷贝数据，默认为 False。</p><p><strong>定义之后就可以使用索引访问Series</strong></p></blockquote><p><strong>还可以从字典创建Series，并可以直接指定使用哪部分列。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sites = &#123;<span class="number">1</span>: <span class="string">&quot;Google&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Wiki&quot;</span>&#125;</span><br><span class="line">s = pd.Series(sites, index = [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="Series属性"><a href="#Series属性" class="headerlink" title="Series属性"></a>Series属性</h3><p><strong>访问Series的主要的属性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.values</span><br><span class="line"><span class="comment"># series值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.name</span><br><span class="line"><span class="comment"># series名字</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.index</span><br><span class="line"><span class="comment"># series索引</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.dtype</span><br><span class="line"><span class="comment"># series属性</span></span><br></pre></td></tr></table></figure><p><strong>还可以使用Series直接调用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.mean()</span><br></pre></td></tr></table></figure><blockquote><p>Series有很多方法可以供调用，具体可以查看说明文档。</p></blockquote><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p><strong>DataFrame 是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）。</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2021/04/pandas-DataStructure.png" alt></p><h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.DataFrame( data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>data</strong>：一组数据(ndarray、series, map, lists, dict 等类型)。</li><li><strong>index</strong>：索引值，或者可以称为行标签。</li><li><strong>columns</strong>：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。</li><li><strong>dtype</strong>：数据类型。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul></blockquote><p><strong>使用列表创建</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [[<span class="string">&#x27;Google&#x27;</span>,<span class="number">10</span>],[<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">12</span>],[<span class="string">&#x27;Wiki&#x27;</span>,<span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data,columns=[<span class="string">&#x27;Site&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>],dtype=<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure><p><strong>使用ndarrays创建</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;Site&#x27;</span>:[<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Wiki&#x27;</span>], <span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><p><strong>使用字典创建</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><h3 id="DataFrame属性"><a href="#DataFrame属性" class="headerlink" title="DataFrame属性"></a>DataFrame属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.index</span><br><span class="line"><span class="comment"># 查看行索引名字</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns</span><br><span class="line"><span class="comment"># 查看列索引名字</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.values</span><br><span class="line"><span class="comment"># 查看值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.shape</span><br><span class="line"><span class="comment"># 查看数据结构大小</span></span><br></pre></td></tr></table></figure><h3 id="取值与操作"><a href="#取值与操作" class="headerlink" title="取值与操作"></a>取值与操作</h3><p><strong>可以直接使用列索引取出一列</strong></p><h4 id="增加列"><a href="#增加列" class="headerlink" title="增加列"></a>增加列</h4><p><strong>可以直接增加新的列，也可以使用assign方法,但assign方法不会对原DataFrame做修改。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1[<span class="string">&#x27;B&#x27;</span>]=<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.assign(C=pd.Series(<span class="built_in">list</span>(<span class="string">&#x27;def&#x27;</span>)))</span><br></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p><strong>对于删除而言，可以使用drop函数或del或pop,pop方法直接在原来的DataFrame上操作，且返回被删除的列。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop(index=<span class="string">&#x27;五&#x27;</span>,columns=<span class="string">&#x27;col1&#x27;</span>) </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.pop(<span class="string">&#x27;col1&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>设置inplace=True后会直接在原DataFrame中改动</p></blockquote><h4 id="根据类型选择列"><a href="#根据类型选择列" class="headerlink" title="根据类型选择列"></a>根据类型选择列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.select_dtypes(include=[<span class="string">&#x27;number&#x27;</span>]).head()</span><br></pre></td></tr></table></figure><h4 id="修改行列名"><a href="#修改行列名" class="headerlink" title="修改行列名"></a>修改行列名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.rename(index=&#123;<span class="string">&#x27;一&#x27;</span>:<span class="string">&#x27;one&#x27;</span>&#125;,columns=&#123;<span class="string">&#x27;col1&#x27;</span>:<span class="string">&#x27;new_col1&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="将Series转换为DataFrame"><a href="#将Series转换为DataFrame" class="headerlink" title="将Series转换为DataFrame"></a>将Series转换为DataFrame</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = df.mean()</span><br><span class="line">s.name=<span class="string">&#x27;to_DataFrame&#x27;</span></span><br><span class="line">s.to_frame()</span><br></pre></td></tr></table></figure><blockquote><p>可<strong>以把处理后的列转换为新的DataFrame</strong></p></blockquote><h3 id="索引对齐特性"><a href="#索引对齐特性" class="headerlink" title="索引对齐特性"></a>索引对齐特性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;,index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;,index=[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">df1-df2 </span><br><span class="line"><span class="comment">#由于索引对齐，因此结果不是0</span></span><br></pre></td></tr></table></figure><blockquote><p>pandas会自动把索引对其排序到相应的位置而不是，按照给出的顺序将进行排序。</p></blockquote><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br><span class="line">df.tail()</span><br></pre></td></tr></table></figure><blockquote><p><strong>分别查看数据的前五行和后五行</strong></p></blockquote><h2 id="unique和nunique"><a href="#unique和nunique" class="headerlink" title="unique和nunique"></a>unique和nunique</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;columns&#x27;</span>].nunique()</span><br><span class="line">df[<span class="string">&#x27;columns&#x27;</span>].unique()</span><br></pre></td></tr></table></figure><blockquote><p><strong>分别会显示唯一值和唯一值的个数</strong></p></blockquote><h2 id="count和value-counts"><a href="#count和value-counts" class="headerlink" title="count和value_counts"></a>count和value_counts</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Physics&#x27;</span>].count()</span><br></pre></td></tr></table></figure><p><strong>检查缺失值的个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Physics&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure><p><strong>返回每个元素有多少个,但不会统计缺失值</strong></p><h2 id="describe和info"><a href="#describe和info" class="headerlink" title="describe和info"></a>describe和info</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.info()</span><br></pre></td></tr></table></figure><p><strong>info返回函数有哪些列，有多少缺失值，每列的类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure><p><strong>describe默认统计数值型数据的各个统计量</strong></p><h2 id="idxmax和nlargest"><a href="#idxmax和nlargest" class="headerlink" title="idxmax和nlargest"></a>idxmax和nlargest</h2><p><strong>idxmax函数返回最大值所在索引，在某些情况下特别适用，idxmin功能类似</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;Math&#x27;].idxmax()</span><br></pre></td></tr></table></figure><p><strong>nlargest函数返回前几个大的元素值，nsmallest功能类似</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;Math&#x27;].nlargest(3)</span><br></pre></td></tr></table></figure><h2 id="clip和replace"><a href="#clip和replace" class="headerlink" title="clip和replace"></a>clip和replace</h2><p><strong>clip是对超过或者低于某些值的数进行截断</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Math&#x27;</span>].clip(<span class="number">33</span>,<span class="number">80</span>).head()</span><br></pre></td></tr></table></figure><p><strong>replace是对某些值进行替换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Address&#x27;</span>].replace([<span class="string">&#x27;street_1&#x27;</span>,<span class="string">&#x27;street_2&#x27;</span>],[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>]).head()</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><strong>对于Series，它可以迭代每一列的值操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Math&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="built_in">str</span>(x)+<span class="string">&#x27;!&#x27;</span>).head() </span><br><span class="line"><span class="comment">#可以使用lambda表达式，也可以使用函数</span></span><br></pre></td></tr></table></figure><p><strong>对于DataFrame，它在默认axis=0下可以迭代每一个列操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.apply(<span class="keyword">lambda</span> x:x.apply(<span class="keyword">lambda</span> x:<span class="built_in">str</span>(x)+<span class="string">&#x27;!&#x27;</span>)).head() </span><br><span class="line"><span class="comment">#这是一个稍显复杂的例子，有利于理解apply的功能</span></span><br></pre></td></tr></table></figure><p><strong>Pandas中的axis参数=0时，永远表示的是处理方向而不是聚合方向，当axis=’index’或=0时，对列迭代对行聚合，行即为跨列，axis=1同理</strong></p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = <span class="built_in">zip</span>(a,b)     </span><br><span class="line"><span class="comment"># 打包为元组的列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(a,c)              </span><br><span class="line"><span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(*zipped)          </span><br><span class="line"><span class="comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;Math&#x27;</span>).sort_index().head()</span><br><span class="line"><span class="comment"># 可以设置ascending参数，默认为升序，True</span></span><br></pre></td></tr></table></figure><blockquote><p>把Math设置成索引，按照索引排序</p></blockquote><h2 id="值排序"><a href="#值排序" class="headerlink" title="值排序"></a>值排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=[<span class="string">&#x27;Address&#x27;</span>,<span class="string">&#x27;Height&#x27;</span>]).head()</span><br></pre></td></tr></table></figure><blockquote><p>按照参数传递的值排序，如果相同按照第二层排序</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupter Notebook 使用整理</title>
      <link href="/2022/01/14/Jupter-Notebook-%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/"/>
      <url>/2022/01/14/Jupter-Notebook-%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda常用命令总结</title>
      <link href="/2022/01/08/Anaconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/08/Anaconda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda命令总结"><a href="#Anaconda命令总结" class="headerlink" title="Anaconda命令总结"></a>Anaconda命令总结</h1><h2 id="配置Anaconda环境变量"><a href="#配置Anaconda环境变量" class="headerlink" title="配置Anaconda环境变量"></a>配置Anaconda环境变量</h2><p>如果想从系统的命令行环境直接进入Anaconda 需要配置环境变量，配置完成后就可以直接在系统的命令行键入<code>activate</code>进入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROOT\anaconda</span><br><span class="line">ROOT\anaconda\Scripts</span><br><span class="line">ROOT\anaconda\Library\bin</span><br></pre></td></tr></table></figure><h2 id="管理conda"><a href="#管理conda" class="headerlink" title="管理conda"></a>管理conda</h2><h3 id="查看conda版本信息"><a href="#查看conda版本信息" class="headerlink" title="查看conda版本信息"></a>查看conda版本信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><h3 id="升级当前版本的conda"><a href="#升级当前版本的conda" class="headerlink" title="升级当前版本的conda"></a>升级当前版本的conda</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><h3 id="创建一个环境"><a href="#创建一个环境" class="headerlink" title="创建一个环境"></a>创建一个环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n name python=x.x</span><br></pre></td></tr></table></figure><blockquote><p>name：环境的名字</p><p>python：python的版本（不指定会默认安装conda所装的那个版本的python）</p></blockquote><h2 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name envname --all</span><br></pre></td></tr></table></figure><h2 id="查看环境列表"><a href="#查看环境列表" class="headerlink" title="查看环境列表"></a>查看环境列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><blockquote><p> 其中<code>*</code>标注的是目前所处的环境，默认在base环境。</p></blockquote><h2 id="切换环境"><a href="#切换环境" class="headerlink" title="切换环境"></a>切换环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate envname</span><br></pre></td></tr></table></figure><h2 id="复制一个环境"><a href="#复制一个环境" class="headerlink" title="复制一个环境"></a>复制一个环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n newenv --clone env</span><br></pre></td></tr></table></figure><h2 id="分享环境"><a href="#分享环境" class="headerlink" title="分享环境"></a>分享环境</h2><blockquote><p>想把当前的环境配置分享，快速建立一个与你一模一样的环境来共同开发验。</p></blockquote><p>首先通过<code>activate target_env</code>要分享的环境<code>target_env</code>，然后输入下面的命令会在当前工作目录下生成一个<code>environment.yml</code>文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; environment.yml</span><br></pre></td></tr></table></figure><p>然后通过使用下面命令就能创建环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f environment.yml</span><br></pre></td></tr></table></figure><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="列举所有当前环境的包"><a href="#列举所有当前环境的包" class="headerlink" title="列举所有当前环境的包"></a>列举所有当前环境的包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><h2 id="查看其它环境中的包"><a href="#查看其它环境中的包" class="headerlink" title="查看其它环境中的包"></a>查看其它环境中的包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n your_env_name</span><br></pre></td></tr></table></figure><h2 id="为特定环境安装某个包"><a href="#为特定环境安装某个包" class="headerlink" title="为特定环境安装某个包"></a>为特定环境安装某个包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name package_name</span><br></pre></td></tr></table></figure><h2 id="安装特定版本的包"><a href="#安装特定版本的包" class="headerlink" title="安装特定版本的包"></a>安装特定版本的包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install package=version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译环境小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的Python-第二章-学习笔记</title>
      <link href="/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="序列构成的数组"><a href="#序列构成的数组" class="headerlink" title="序列构成的数组"></a>序列构成的数组</h1><h2 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h2><ul><li><p>python标准库用C实现了丰富的序列类型，列举如下</p><ul><li><p>容器序列</p><ul><li>list，tuple和collections.deque这些序列能存放不同类型的数据。</li></ul></li><li><p>扁平序列</p><ul><li>str，bytes，bytearray，memoryview和arry.arry，这类序列只能容纳一种类型。</li></ul><blockquote><p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平对象中存储的是值而不是引用。</p></blockquote></li></ul></li><li><p>可以以按照能否被修改来分类：</p><ul><li>可变序列<ul><li>list，byterarray，array.array，collections.deque和memoryview。</li></ul></li><li>不可变序列<ul><li>tuple，str和bytes</li></ul></li></ul></li></ul><h2 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h2><h3 id="列表推导和可读性"><a href="#列表推导和可读性" class="headerlink" title="列表推导和可读性"></a>列表推导和可读性</h3><p>列表推导可以帮我们把一个序列或者是一个可迭代的元素过滤和加工，然后再新建一个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;#$^&amp;*&#x27;</span></span><br><span class="line">code = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">    code.append(<span class="built_in">ord</span>(symbol))</span><br><span class="line"></span><br><span class="line">code = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br><span class="line"><span class="comment"># ord()返回字符的编码</span></span><br></pre></td></tr></table></figure><p>代码块中展示了两种生成新列表的方法，分别是朴素的for循环，和列表推导的，我们在使用列表推导的时候，应该遵循以下规则：</p><ul><li>尽量只用列表推导获取新的表达式，尽量保持简短。</li><li>在列表推导的代码超过两行以后，我们应该考虑使用for来重写代码。</li></ul><h3 id="列表推导和filter和map的比较"><a href="#列表推导和filter和map的比较" class="headerlink" title="列表推导和filter和map的比较"></a>列表推导和filter和map的比较</h3><p>使用filter和map的函数组合也可以完成和列表推导一样功能的代码，但是可读性大大减低：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(symbol) &gt; <span class="number">40</span>]</span><br><span class="line"></span><br><span class="line">code = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> c: c&gt;<span class="number">40</span>, <span class="built_in">map</span>(<span class="built_in">ord</span>,symbols)))</span><br></pre></td></tr></table></figure><blockquote><p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该函数接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><p>同时，我们看到在列表推导中，我们还可以在后边加上判断条件用以加强列表推导的作用。</p></blockquote><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>本部分展示的是嵌套循环的列表推导，我们可以使用列表推导直接用一句写好嵌套循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors = <span class="string">&#x27;black red&#x27;</span>.split()</span><br><span class="line">sizes = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [(color,size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br></pre></td></tr></table></figure><ul><li>如果我们要改变循环嵌套的顺序，我们可以改变两个for的顺序。</li><li>如果想生成其它类型的序列，生成器表达器就派上了用场。</li></ul><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器表达式可以产生除了列表之外的序列，包括元组等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tp = <span class="built_in">tuple</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line">ay = array.array(<span class="string">&#x27;I&#x27;</span>,(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>当我们使用列表推导类的代码时，将会节省很多for循环的开销，所以产出新列表时可以尽量使用列表推导。</li></ul><h2 id="元组不仅仅是不可变的列表"><a href="#元组不仅仅是不可变的列表" class="headerlink" title="元组不仅仅是不可变的列表"></a>元组不仅仅是不可变的列表</h2><ul><li>除了元组作为不可变的列表，而且还应该有另一个作用，没有字段名的记录。</li></ul><h3 id="元组和记录"><a href="#元组和记录" class="headerlink" title="元组和记录"></a>元组和记录</h3><p>我们可以利用元组，并且我们需要使用元组的其他性质来对编码进行一些有意义的帮助：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d = (<span class="string">&#x27;zhongguo&#x27;</span>,<span class="string">&#x27;neimenggu&#x27;</span>,<span class="string">&#x27;chifeng&#x27;</span>,<span class="number">88563</span>)</span><br><span class="line"></span><br><span class="line">l = [(a,b) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a,_ <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><ul><li>代码中展示了元组的另外两个功能：<ul><li>首先是快捷赋值</li><li>其次是使用占位符来进行元组拆包</li></ul></li></ul><h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>元组拆包有很多种表现形式：</p><ul><li><p>平行赋值就是最好辨认的元组拆包表现形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d = (<span class="string">&#x27;zhongguo&#x27;</span>,<span class="string">&#x27;neimenggu&#x27;</span>,<span class="string">&#x27;chifeng&#x27;</span>,<span class="number">88563</span>)</span><br></pre></td></tr></table></figure></li><li><p>不需要其它变量来进行的交换也是一种元组拆包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure></li><li><p><strong>可以使用*运算符把一个可迭代对象拆分为函数的参数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">20</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">divmod</span>(*t)</span><br></pre></td></tr></table></figure></li><li><p><strong>我们可以使用_作为占位符来读取数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">_,filename = os.path.split(<span class="string">&#x27;/home/document/hello.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(filename)</span><br></pre></td></tr></table></figure></li><li><p>在python3中，元组拆包中的平行赋值被进一步扩展，可以把*作为前缀代表不确定数目的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a,b,*rest = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">out: <span class="number">0</span> <span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    </span><br><span class="line">a,*body,c,d = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">out: <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><ul><li><p>接受表达式的元组可以是嵌套式的，只要接受元组的嵌套结构符合表达式本身的嵌套结构就可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = (<span class="string">&#x27;country&#x27;</span>,<span class="string">&#x27;city&#x27;</span>,<span class="number">36.933</span>,(<span class="number">35.58</span>,<span class="number">139.69</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name,cc,pop,(latitude,longitude) <span class="keyword">in</span> metro_areas:</span><br><span class="line"><span class="keyword">if</span> longgitude &lt;=<span class="number">0</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>代码中通过for取得metro中的元组。</p></blockquote></li></ul><h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><ul><li><p>当我们需要一个小型的只有属性没有方法的对象时，我们可以通过collections.namedtuple来构建一个类。</p><blockquote><p>当我们使用此种方法构建一个小型的类的时候，占用的内存回避对象实例小很多，因为python</p><p>不会使用__dict__来存放类的属性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student = namedtuple(<span class="string">&#x27;Student&#x27;</span>, <span class="string">&#x27;name sex grade&#x27;</span>)</span><br><span class="line">Teacher = namedtuple(<span class="string">&#x27;Teacher&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;grade&#x27;</span>])</span><br><span class="line"></span><br><span class="line">te = Teacher(<span class="string">&#x27;wang&#x27;</span>, <span class="string">&#x27;female&#x27;</span>, (<span class="number">100</span>,<span class="number">99</span>))</span><br><span class="line">me = Student(<span class="string">&#x27;shengyuejiang&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,(<span class="number">98</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p><strong>定义和使用具名元组的几点注意：</strong></p></li><li><p>创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由<strong>数个字符串祖成的可迭代对象</strong>，或者由<strong>空格分开的字段名组成的字符串</strong>。</p></li><li><p>在创建实例的时候，我们可以直接把值传进构造函数作为参数。</p></li><li><p>我们可以通过字段名或者位置来直接获取一个字段的信息。</p><blockquote><p>如果我们通过此种方式来进行创建具名元组，我们就可以通过使用属性名字和索引获取一个值了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Grade = namedtuple(<span class="string">&#x27;Grade&#x27;</span>, <span class="string">&#x27;math english&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_data = (<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,Grade(<span class="string">&#x27;98&#x27;</span>,<span class="string">&#x27;55&#x27;</span>))</span><br><span class="line">xiaoming = Student._make(new_data)</span><br><span class="line"></span><br><span class="line">xiaoming._asdict()</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> xiaoming._asdict().items():</span><br><span class="line">    <span class="built_in">print</span>(key,<span class="string">&#x27;:&#x27;</span>,value)</span><br></pre></td></tr></table></figure><p><strong>其它属性:</strong></p></li><li><p>我们可以通过_fields来访问这个类所有字段名称的元组。</p></li><li><p>使用_make()通过接受一个可迭代对象来生成这个类的一个实例，也可以写成Student(*new_data)</p></li><li><p>我们还可以使用_asdict()来把对象抽象成一个字典，然后通过字典的方式把数据展现出来。</p></li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="为什么切片和区间会是左闭右开的"><a href="#为什么切片和区间会是左闭右开的" class="headerlink" title="为什么切片和区间会是左闭右开的"></a>为什么切片和区间会是左闭右开的</h3><ul><li>当我们的下标从0开始时即时我们只有最后一个元素的下标，我们也能很快就知道切片和区间有几个元素，比如range（3）一看就知道返回三个元素。</li><li>当起止位置都可见时，我们可以快速计算出列表中有几个元素，例如<strong>list[1:3]</strong>我们一下就看出来有两个元素。</li><li>这样我们就可以用一个索引直接把列表分割成不重叠的两个部分，只要写成<strong>list[:x]</strong>和<strong>list[x:]</strong>就可以了。</li></ul><h3 id="对对象进行切片"><a href="#对对象进行切片" class="headerlink" title="对对象进行切片"></a>对对象进行切片</h3><ul><li><p>首先我们知道python可以对列表进行以某种步长进行切片的操作，其中的步长可正可负。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span>:s = <span class="string">&#x27;bicycle&#x27;</span></span><br><span class="line"><span class="keyword">in</span>:s[::<span class="number">3</span>]</span><br><span class="line">out:<span class="string">&#x27;bye&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">in</span>:s[::-<span class="number">1</span>]</span><br><span class="line">out:<span class="string">&#x27;elcycib&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>:s[::-<span class="number">2</span>]</span><br><span class="line">out:<span class="string">&#x27;eccb&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在切片时，我们使用这种方法返回的其实是一个切片对象<strong>slice(a,b,c)</strong>,最终会调用seq.__gititem__(slice(start,stop,step))，我们可以对这个对象命名旨在于我们可以增加切片的可读性，就像在使用表格软件对某部分命名一样。</p></li></ul><h3 id="多维切片和省略"><a href="#多维切片和省略" class="headerlink" title="多维切片和省略"></a>多维切片和省略</h3><ul><li>[]运算符还可以使用以逗号分开的多个索引或者是切片，外部库Numpy就是用了这个特性，二维的Numpy.ndarray就可以用a[i,j]这种形式来获取，或者是使用a[m:n,k:j]的方式来得到二维切片。</li><li>省略的正确书写方法是三个英语句号(…)，可以当作切片规范中的一部分，也可以用在函数的参数清单中，比如f(a,…,z),或a[i:…]。如果a是一个四维数组，那么后者就表示a[i , : , : , :]。</li></ul><h3 id="给切片赋值"><a href="#给切片赋值" class="headerlink" title="给切片赋值"></a>给切片赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">l[<span class="number">5</span>:<span class="number">7</span>] = [<span class="number">50</span>,<span class="number">50</span>]</span><br><span class="line">l[<span class="number">5</span>:<span class="number">6</span>] = [<span class="number">100</span>]</span><br></pre></td></tr></table></figure><ul><li>我们可以根据情况对切片进行赋值，这样会改变原列表的值，需要注意的是即时切片中只有一个元素，我们也需要把它定义成可迭代的对象来进行赋值。</li></ul><h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h2><ul><li>+会把两侧的序列拼接起来，需要注意的是此种操作可以对相同类型的可迭代的数据类型进行操作。</li><li>*会快捷的把序列进行几次复制连接在一起。</li></ul><h3 id="建立由列表组成的列表"><a href="#建立由列表组成的列表" class="headerlink" title="建立由列表组成的列表"></a>建立由列表组成的列表</h3><ul><li><p>当我们需要初始化一个嵌套着几个列表的列表，最好的选择是进行列表推导。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">borad = [[<span class="string">&#x27;_&#x27;</span>]*<span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">board[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">out :[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>建立一个包含三个列表的列表，被包含的三个列表各自有三个元素。</p></blockquote></li><li><p>注意：有一个看起来很快速的建表方法其实是个陷阱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">board_test = [[<span class="string">&#x27;_&#x27;</span>]*<span class="number">3</span>]*<span class="number">3</span></span><br><span class="line">board_test[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"></span><br><span class="line">out :[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>当我们尝试改变其中一个元素时，我们会发现所有三个位置的元素都改变了，因为列表中的三个元素实际上是三个引用，而不是预先我们想要的效果。</p></blockquote></li></ul><h2 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h2><ul><li>自增运算符（*=，+=）的的表现取决于它们的第一个操作对象。</li><li>其背后的方法是<em>_iadd</em>_(),如果类没有实现这个方法就会调用__add()__。</li><li>可变序列一般都实现了自增的发给发，但是不可变序列一般都没有实现，所以会导致代码效率变低。</li></ul><h3 id="一个关于-的谜题"><a href="#一个关于-的谜题" class="headerlink" title="一个关于+=的谜题"></a>一个关于+=的谜题</h3><ul><li><p>如果在不可变序列中存入可变序列，再对可变序列自增会导致报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span>, <span class="number">20</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">30</span>,<span class="number">40</span>]</span><br></pre></td></tr></table></figure></li><li><p>得出的经验：</p><ul><li>不要把可变序列存入不可变序列中</li><li>增量赋值不是一个原子操作，而是关乎整个序列</li></ul></li></ul><h2 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h2><p><strong>两个排序方法</strong>：</p><ul><li><strong>sort():</strong> 可以对可变序列进行原地排序，会改变原有的列表。</li><li><strong>sorted():</strong> 会复制一份原有的列表进行排序，返回一个新的列表</li></ul><p><strong>两个排序方法都有的两个参数：</strong></p><ul><li><strong>reverse：</strong>如果此参数为True会进行逆序排列</li><li><strong>key：</strong>进行排序的标准，可以选择进行长度排序(len)或者忽视大小写(str.lower)，默认是恒等函数。</li></ul><h2 id="用bisect来管理已经排序的序列"><a href="#用bisect来管理已经排序的序列" class="headerlink" title="用bisect来管理已经排序的序列"></a>用bisect来管理已经排序的序列</h2><h3 id="用bisect来进行搜索"><a href="#用bisect来进行搜索" class="headerlink" title="用bisect来进行搜索"></a>用bisect来进行搜索</h3><ul><li><strong>bisect(haystack, needle)</strong>: 可以在haystack中搜索needle的位置，该位置满足的条件是把needle插入这个位置之后，haystack还能保持升序。</li><li>可以通过参数控制作用范围，和搜寻范围，此处略。</li><li>此函数还有两个子函数，分别是bisect_left（）和bisect_right（）可以控制搜寻的索引插入的位置是在左还是右。</li></ul><h3 id="用bisect-insort插入新元素"><a href="#用bisect-insort插入新元素" class="headerlink" title="用bisect.insort插入新元素"></a>用bisect.insort插入新元素</h3><ul><li><strong>insort(seq, item)</strong>把变量item插入到序列seq中，并能保持seq的升序顺序。</li></ul><blockquote><p> <strong>上述几个方法比较简单不做示范</strong></p></blockquote><h2 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p> <strong>如果我们需要一个只包含数字的列表，那么array.array比list更高效。</strong></p><ul><li>array拥有list拥有的大多数方法，同时还有很多优点，下面这个实例演示了数组的使用方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">floats = array(<span class="string">&#x27;d&#x27;</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>**<span class="number">7</span>)))</span><br><span class="line"><span class="built_in">print</span>(floats[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;float.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">floats.tofile(fp)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line">floats2 = array(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;float.bin&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">floats2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(floats2[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><ul><li>在本例中我们使用array创建了一个有1000万个浮点数的数组，我们还可以使用读写等操作非常方便</li><li>当我们使用array数组的时候，还会大大减少运行内存的空间和占用的储存空间</li></ul><blockquote><p>注意：数组类型不支持原地排序算法，只能使用sorted这种方法进行排序，但是我们还可以使用bisect来进行插入等操作。</p></blockquote><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p>memory是一个内置类，可以让用户在不复制内容的情况下操作同一个数组的不同切片。</p><h3 id="Numpy和Scipy"><a href="#Numpy和Scipy" class="headerlink" title="Numpy和Scipy"></a>Numpy和Scipy</h3><p>Numpy和Scipy提供高阶数组和矩阵操作，速度非常快，不在此处再介绍，将当作数据分析工具卸载其它文章中。</p><h3 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h3><p><strong>当我们的变成过程中需要使用队列的操作时，列表可以简单的进行替代，但是很麻烦，python中提供了队列类。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)</span><br><span class="line">dq.rotate(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)</span><br><span class="line">dq.appendleft(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(dq)</span><br><span class="line">dq.extendleft([-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(dq)</span><br></pre></td></tr></table></figure><p><strong>out：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line">deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)</span><br><span class="line">deque([-1, 7, 8, 9, 0, 1, 2, 3, 4, 5], maxlen=10)</span><br><span class="line">deque([-3, -2, -1, -1, 7, 8, 9, 0, 1, 2], maxlen=10)</span><br></pre></td></tr></table></figure><ul><li>maxlen规定了队列的最大值</li><li>队列的旋转操作可以把传入的参数在队列右侧移动到队列的左侧</li><li>当队列满时再添加元素会把最后一个元素删除</li><li>extendleft会把迭代器中的元素添加到队列的左边，因此元素会逆序出现在队列里</li></ul><blockquote><p>此类对两侧的操作做了优化，代价就是在中间读取元素会很慢，如果需要频繁使用前后的元素可以选择队列这个类</p></blockquote><p><strong>其他的队列类：</strong></p><ul><li>queue：提供了同步类Queue，LifoQueue和PriorityQueue，特点是如果队列满了就会被锁住，知道另外的线程移除了某个元素腾出了位置。</li><li>multiproccessing：实现了自己的Queue，设计给进程间通信使用，可以让任务管理更加方便</li><li>heapq：提供了heappush和heappop方法可以把可变序列当作堆列或者优先队列使用</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>列表推导和生成器表达式是一种非常简约的写法，可以生成一些预先需要生成的序列</strong></li><li><strong>使用_作为占位符来占去我们不关心的元素的位置，和使用*来代表我们位置个数的元素非常实用</strong></li><li><p><strong>嵌套元组拆包可以从元组中获取我们想要的格式，同时具名元组可以帮我们定义没有方法只需要存取值的小型类</strong></p></li><li><p><strong>在为有序的序列进行插入操作时，最好使用bisect</strong></p></li><li><strong>在使用序列的时候一定要灵活，如果我们需要存储大量数字的时候可以使用数组</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流畅的Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流畅的Python-第一章-学习笔记</title>
      <link href="/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python数据类型"><a href="#python数据类型" class="headerlink" title="python数据类型"></a>python数据类型</h1><ul><li><p>不管在那种框架下书写程序，我们都会花费大量的时间去实现那些会被框架本身调用的方法。</p></li><li><p>python在碰到特殊的句法的时候，会使用特殊方法去激活一些基本的对象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾。</p><blockquote><p>例如当我们使用某种根据索引找到值的语法时，实际上python是在调用一个名为<strong>getitem</strong>的方法，为了实际求得某值实际上，解释器会调用这个方法来完成。</p></blockquote></li><li><p>这些特殊的方法可以让我们自己的对象实现和支持以下的语言架构，并且与其交互：</p><ul><li>迭代</li><li>集合类</li><li>属性访问</li><li>运算符重载</li><li>函数和方法的调用</li><li>对象的创建和销毁</li><li>字符串表示形式和格式化</li><li>管理上下文</li></ul><blockquote><p>博主理解：在我们要实现某个类的时候，我们有时候会花费大量的时间来进行python已经准备好的功能，这会增加我们的工作量，做重复的共做，一旦我们使用了魔术方法，我们就可以赋予我们自己的对象python的某些内置功能，包括但不限于索引等。</p></blockquote></li></ul><h2 id="一摞python风格的纸牌"><a href="#一摞python风格的纸牌" class="headerlink" title="一摞python风格的纸牌"></a>一摞python风格的纸牌</h2><p>此部分作者用十几行代码展示了，python特殊方法的用法，通过这个例子我们可以看到作者大大非常强大。</p><ul><li><p>首先，作者调用了collections的namedtuple方法，本方法旨在于构建只有少数的属性但是没有方法的对象，并且在这两条语句中我们简单的定义了一个纸牌对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">&quot;Card&quot;</span>, [<span class="string">&#x27;rank&#x27;</span>,<span class="string">&#x27;suit&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>语法：<br><em>collections.namedtuple(typename, field_names, \</em>, verbose=False, rename=False, module=None)*</p><p>其中：</p><p><code>typename</code>：实际上就是你通过<code>namedtuple</code>创建的一个元组的子类的类名，通过这样的方式我们可以初始化各种各样的实例化元组对象。</p><p><code>field_names</code>：类似于字典的<code>key</code>，在这里定义的元组可以通过这样的<code>key</code>去获取里面对应索引位置的元素值，这样的key可以是列表，也可以是用<code>空格、/和逗号</code>这样的分隔符隔开的字符串。</p><p><code>rename</code>：如果<code>rename</code>指定为<code>True</code>，那么你的<code>field_names</code>里面不能包含有<code>非Python标识符，Python中的关键字以及重复的name</code>，如果有，它会默认给你重命名成‘<code>_index</code>’的样式，这个<code>index</code>表示该<code>name</code>在<code>field_names</code>中的索引，例：<code>[&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;, &#39;abc&#39;]</code> 将被转换成<code>[&#39;abc&#39;, &#39;_1&#39;, &#39;ghi&#39;, &#39;_3&#39;]</code>。</p><p><strong>注意:在这里我们定义了一个名为Card的对象，里面有rank和suit两个属性，分别用来存储花色和点数，此处定义的是单个纸牌的对象。</strong></p></blockquote></li><li><p>然后使用很多的魔术方法来定义一整个扑克牌的类定义，首先是整个对象的属性部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deck</span>:</span></span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>)) + <span class="built_in">list</span>(<span class="string">&quot;JQKA&quot;</span>)]</span><br><span class="line">    suits = <span class="string">&#x27;hongtao heitao meihua fangpian&#x27;</span>.split()</span><br></pre></td></tr></table></figure><blockquote><p>博主理解:本处的两个定义太那个了，简直就是集大成。rank的列表定义使用了一行的for循环，一行for循环的基本语法格式为：</p><ul><li>[expression for x in L]</li></ul><p>另外在迭代器的构建方面，作者使用了非常简约的两个列表相加的模式，秒啊！（可能也是我太菜了</p><p>在定义suits时，作者使用了split构建字符串列表，常规操作，不过很简约。</p></blockquote></li><li><p>最后就是是就是使用魔术方法来进行方法的书写部分，然后来见证奇迹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deck</span>:</span></span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>)) + <span class="built_in">list</span>(<span class="string">&quot;JQKA&quot;</span>)]</span><br><span class="line">    suits = <span class="string">&#x27;hongtao heitao meihua fangpian&#x27;</span>.split()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks] + [Card(<span class="string">&#x27;wang&#x27;</span>, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> [<span class="string">&#x27;big&#x27;</span>,<span class="string">&#x27;small&#x27;</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,position</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure></li><li><p>首先我们通过collections内的namedtuple方法，可以很轻松的得到一个单个纸牌对象：</p><p><img src="/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_1.png" alt></p></li><li><p>通过魔术方法定义的对象使我们可以直接调用<strong>len()</strong>来查看一叠纸牌有多少张：</p><p><img src="/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_2.png" alt></p></li><li><p>同时我们也可以进行诸如，索引，随机选择，切片，迭代等通常我们在python内置数据结构中使用的很多功能，这些都是由<strong>getitem</strong>提供的：</p><p><img src="/2021/12/11/%E6%B5%81%E7%95%85%E7%9A%84Python-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_3.png" alt></p></li><li><p>我们使用特殊方法的两个好处：</p><ul><li>作为类的用户我们不必再去思考我们造轮子制造出来的函数方法，比如如何取到我们对象的长度，到底我们定义的是什么名字。</li><li>可以更加方便地使用python的标准库进行开发，比如random，我们可以直接把对象作为参数进行调用。</li></ul></li><li><p>仿照作者的例子写了一副麻将牌：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ma = collections.namedtuple(<span class="string">&#x27;Ma&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>,<span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mahjong</span>:</span></span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">    suiit = <span class="string">&#x27;tiao bing wan&#x27;</span>.split() * <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._Ma = [Ma(rank,suit) <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks <span class="keyword">for</span> suit <span class="keyword">in</span> self.suiit] + [Ma(rank,<span class="string">&#x27;feng&#x27;</span>) <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="string">&#x27;dong nan xi bei&#x27;</span>.split()*<span class="number">4</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._Ma)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,position</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._Ma[position]</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h2><ul><li>特殊方法的存在其实是为了被python解释器调用的，我们自己并不需要去调用它们。所以我们在书写代码的时候可以直接写<strong>len(x)</strong>而不是<strong>my<em>object.\</em>_len__()</strong>，如果python发现<strong>x</strong>是用户自己定义的对象，那么python会自己调用我们重写的<strong>my<em>object.\</em>_len__()</strong>。</li><li>如果使用python内置的数据结构，python通常会直接调用底层的属性而不是再使用特殊方法，旨在于提高运行速度。</li><li>很多时候特殊方法是隐性调用的，我们无需直接使用特殊方法。</li></ul><h3 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h3><ul><li><p>刚才我们使用部分特殊方法实现了一些索引等功能，实际上我们还可以使用部分特殊方法实现我们所需要的数值类型的功能。</p></li><li><p>简单的二维向量对象定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x = <span class="number">0</span>, y = <span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;vetor(%r, %r)&#x27;</span>%(self.x, self.y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> vector(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self,scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h3><ul><li>python中的内置函数__repr__()能把一个对象用字符串的形式表达出来，不然我们直接打印对象时，将会直接打印出地址信息等。</li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><ul><li>我们通过__add<em>_()和\</em>_mul__()为向量对象带来了+和*两个算数运算符。</li><li>注意：我们最终获得的向量对象是新创建出来的，我们并没有对原始的两个对象做操作。</li></ul><h3 id="自定义的布尔值"><a href="#自定义的布尔值" class="headerlink" title="自定义的布尔值"></a>自定义的布尔值</h3><ul><li>我们通过__bool__()改变了bool的方法，在此处我们定义bool()，当向量不为0的时候为真，为0时为假。</li></ul><h3 id="特殊方法表格"><a href="#特殊方法表格" class="headerlink" title="特殊方法表格"></a>特殊方法表格</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F13371820-ddd42a4f47406038.png&amp;refer=http%3A%2F%2Fupload-images.jianshu.io&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641815722&amp;t=c221dc71e6c413bf53ad74d0797fa093" alt></p><h2 id="关于len不是普通方法的解释"><a href="#关于len不是普通方法的解释" class="headerlink" title="关于len不是普通方法的解释"></a>关于len不是普通方法的解释</h2><ul><li>在python内置数据结构调用特殊方法的功能时，python将会直接从C结构体中读取对象而不是调用特殊方法，特殊方法只是给我们提供了定义自己的对象的时候的一种方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流畅的Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第九章</title>
      <link href="/2021/12/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
      <url>/2021/12/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络的学习过程"><a href="#神经网络的学习过程" class="headerlink" title="神经网络的学习过程"></a>神经网络的学习过程</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>神经网络分类问题有两种：</p><ul><li>二分类问题：<ul><li>只有一个输出单元</li></ul></li><li>多分类问题：<ul><li>有k个输出单元</li></ul></li></ul><p><strong>神经网络中使用的是逻辑回归中的代价函数</strong></p><p><strong>逻辑回归中的代价函数：</strong></p><script type="math/tex; mode=display">J(\theta) = \frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y^{(i)}) = -\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}log(h_\theta(x)+(1-y^{(i)})log(1-(h_\theta(x))]</script><p><strong>神经网络中的代价函数：</strong></p><p><img src="/2021/12/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/ch9_1.png" alt></p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第八章</title>
      <link href="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
      <url>/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="非线性假设"><a href="#非线性假设" class="headerlink" title="非线性假设"></a>非线性假设</h2><p>当我们使用线性模型拟合非线性的数据集时，特征量通常会很多，如果再构造高阶多项式，我们的回归模型复杂度将会非常高。</p><p><strong>例子</strong></p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_1.png" alt="例图"></p><p>假设我们仅使用50*50的像素灰图片，选择每个像素点为特征，则特征总量为N=2500,如果选用RGB则N=7500，如果将两个组合为新特征，则特征数为30，000，000个</p><h2 id="神经元和大脑"><a href="#神经元和大脑" class="headerlink" title="神经元和大脑"></a>神经元和大脑</h2><p>神经网络就源于模拟人类大脑，但需要计算的量很大。随着计算机硬件性能的提高，神经网路又重新变为主流机器学习应用算法。</p><p>我们希望开发一种算法，可以对传进来的任何数据进行处理学习。</p><h2 id="模型展示"><a href="#模型展示" class="headerlink" title="模型展示"></a>模型展示</h2><p>我们一般把神经网络分为三部分，即输入层，隐藏层，输出层。</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_2.png" alt="模型展示"></p><p>图中输入层对应输入单元，隐藏层对应中间单元（但不一定是一层），输出层对应的是输出单元。中间单元应用激活函数处理数据。</p><p>我们定义：</p><blockquote><p>$x_0$:偏置单元，$x_0=1$</p><p>$\theta$:参数，权重</p><p>激活函数：g，即逻辑函数等</p><p>输入层：对应训练集中的特征x</p><p>输出层：对应于训练集的结果y</p><p>$ a_i^{(j)} $:第j层的第i个激活单元</p><p>$\theta^{(j)}$:从第j层映射到第j+1层的权重矩阵</p><p>$\theta^{(j)}_{v,u}$:从第j层第u个单元映射到第j+1层的第v个单元的权重</p><p>$s_j$:第j层的激活单元数目</p></blockquote><p><strong>向前传播</strong>：</p><p>对输入层的所有激活单元应用激活函数，得到隐藏层的输入，对于接下来的每一层都通过激活函数，一层一层的向下计算传递结果。</p><p><strong>向量化实现</strong>：</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_2.png" alt="向量化实现"></p><p>更一般的：</p><p>$z<em>i^{(j)}=\theta</em>{i,0}^{(j-1)}a<em>0^{(j-1)}+\theta</em>{i,1}^{(j-1)}a<em>1^{(j-1)}+…+\theta</em>{i,n}^{(j-1)}a_n^{(j-1)}$</p><p>$z^{(j)}=\theta^{j-1}a^{j-1}$</p><p>$a^{(j)}=g(z^{(j)})$</p><p>扩展到所有样本实例：</p><p>$z^{(2)}=\theta^{(1)}X^T$</p><p>这时是一个$ s_2*m $的矩阵</p><blockquote><p>m:训练集中的样本实例数目</p><p>$s_2$:第二层神经网络中激活单元的数目</p></blockquote><p>神经网络也可以有多层，每层激活单元的数目是不固定的：</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_3.png" alt="多层神经网络"></p><h2 id="例子直观理解"><a href="#例子直观理解" class="headerlink" title="例子直观理解"></a>例子直观理解</h2><p><strong>例1</strong></p><p>为了更好的演示神经网络的工作过程，以单层网络进行逻辑运算的拟合作为例子。</p><p>下面的例子中$x_1x_2$为二进制数</p><p>逻辑与运算神经网络：</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_4.png" alt="神经网络例子"></p><p>$ \theta^{(1)}=[-30，20，20] ，h_\theta(x)=g(-30+20x_1+20x_2)$</p><p>回归激活函数图像，对应图中表格，就实现了一个能够进行与运算的神经网络。</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_5.png" alt="激活函数"></p><p><strong>例2</strong></p><p>下面将构建一个更为复杂的神经网络</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_6.png" alt="神经网络例子"></p><p>我们通过拟合逻辑与，或，非的运算得到了三个单层简单的运算。</p><p>下面我们将三个简单的单层神经网络组合进行更为复杂的神经网络运算。</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_7.png" alt="神经网络例子"></p><blockquote><p>在隐藏层中我们添加了一个偏置项，控制最后的输出。</p></blockquote><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>在很多实际问题中，我们将会面临很多复杂的问题，当我们需要进行多分类问题时，我们只需要把最终的输出层以及输入时的标签都改成四维向量进行拟合模型就可以了。</p><p><img src="/2021/11/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0/ch8_8.png" alt="多分类问题"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第七章</title>
      <link href="/2021/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <url>/2021/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><p>拟合效果的三种情况：</p><ul><li><p>欠拟合</p><p>没有很好的拟合实际的数据集，导致预测的效果不好。</p></li><li><p>合理拟合</p><p>很好的拟合程度，能给出不错的结果。</p></li><li><p>过拟合</p></li></ul><p>​        过分的考虑了数据集所包含的信息，使得拟合程度很高，泛化程度很低，拟合模型过于复杂时会导致这种情况的发生。</p><p><img src="/2021/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/ch7_1.png" alt="过拟合图"></p><p> 解决过拟合的两个办法：</p><ul><li>尽量选择少的特征进行训练模型<ul><li>缺点是会舍弃部分特征</li></ul></li><li>正则化：考虑每一个特征对最终预测的影响，进行适当的调整。</li></ul><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>很多时候，由于特征数目很多我们并不知道预先要保留哪些特征，我们就可以应用正则化来进行对特征处理。</p><p>在某些实际问题中，我们最终拟合的假设函数可能是一些带有高阶参数的函数，例如，$ \theta_0 + \theta_1x+ \theta_1x^2+ \theta_3x^3+\theta_4x^4$,正是由于高次未知数的存在使得我们最终的曲线很复杂导致了过拟合的结果。</p><p>我们可在不减小特征数目的情况下，如果能消除高次未知数的影响，最终的函数就能变得简单。</p><p>为了保留各部分的参数，我们不修改假设函数，我们可以修改代价函数来控制高次未知数：</p><script type="math/tex; mode=display">\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 + 1000*\theta_3^2 + 1000*\theta_4^2</script><p>上式中，随着我们对代价函数进行最小化，我们同时也对高次未知数做了最小化处理，最终会使得假设函数变得很简单。</p><p><img src="/2021/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/ch7_2.png" alt="代价函数图"></p><p>上边我们提到，将会选择参数进行缩小，最终使得假设函数尽可能地简单来避免过拟合的问题，但是由于实际问题中我们预先并不知道该选择什么参数进行缩小，所以我们缩小所有参数来一定程度上避免过拟合问题。</p><p>我们提出下面的公式来描述正则化：</p><script type="math/tex; mode=display">\frac{1}{2m}[\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}\theta_j^2]</script><p>其中λ是正则化参数，类似于学习效率α也需要我们进行选择</p><ul><li>λ过大时<ul><li>无法有效的拟合数学模型</li><li>梯度下降可能无法收敛</li></ul></li><li>λ过小时<ul><li>无法有效解决过拟合问题</li></ul></li></ul><blockquote><p>奥卡姆剃刀原理：“切勿浪费较多东西去做，用较少的东西，同样可以做好的事情。”</p><p>正则化便符合奥卡姆剃刀原理，是我们解决过拟合一个行之有效的手段，我们可以认为复杂的模型具有较大的先验概率，简单的模型有较小的先验概率。</p></blockquote><h2 id="线性回归正则化"><a href="#线性回归正则化" class="headerlink" title="线性回归正则化"></a>线性回归正则化</h2><p><img src="/2021/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/ch7_3.png" alt="线性回归正则化"></p><p>上图中上半部分就是，我们为线性回归代价函数加入了正则化项的梯度下降算法的式子。</p><blockquote><p>注意：我们不对$ \theta_0 $做任何的惩罚。</p></blockquote><p>下半部分是我们添加了正则化项的代价函数后的另一种表达形式，前半部分的式子在进行梯度下降后会得到一个系数，它总是小于1，我们可以直观地认为它缩小了正在优化的参数。</p><h2 id="逻辑回归正则化"><a href="#逻辑回归正则化" class="headerlink" title="逻辑回归正则化"></a>逻辑回归正则化</h2><p><img src="/2021/11/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0/ch7_4.png" alt="逻辑回归正则化"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第六章</title>
      <link href="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><blockquote><p>虽然逻辑回归名字里有回归，但是是实际上是一个描述分类的算法。</p></blockquote><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><p>邮件问题：是不是垃圾邮件？</p><p>肿瘤问题：是不是恶性肿瘤？</p><script type="math/tex; mode=display">y\in(0,1)</script><p>0：通常表示负类。</p><p>1：通常表示正类。</p><blockquote><p>多分类问题是二分类问题的扩展。  </p></blockquote><p><strong>样例</strong>：</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_1.png" alt="引出逻辑回归问题图"></p><p>图中是一个二分类问题，我们的目标是预测最终的离散结果。</p><blockquote><p>在分类问题中，我们通常会设置一个阈值，来对最终的$h(x)$的输出结果进行判断。</p></blockquote><p>本样例中假设我们选择0.5作为阈值，即：</p><script type="math/tex; mode=display">h(x)\geq 0.5 $$则我们预测$y=1$,即正类；$$ h(x)< 0.5 $$则我们预测$y=0$,即负类。当我们使用线性回归拟合数据时，我们发现:- 加入了偏差项，即右侧点后线性回归所拟合的直线并不能很好的对数据集进行分类。- 线性回归的输出为实数集，当线性回归给出很大或者很小的数值时$y\notin(0,1)$。和线性回归不同逻辑回归是一个分类算法，其输出值在(0,1)范围内，可以更好的解决问题## 假设函数表示我们的目标：$0\leq h_\theta(x)\leq1$原本的函数：$ h_\theta(x) = \theta^Tx$> 通过将$ h_\theta(x)$的输出作为另一个函数$ g(x) $的输入，最终得到一个$ \in(0,1)$的输出，用于分类。定义的激活函数：$ g(z) = \frac{1}{1+e^-z} $当我们把原本的函数带入激活函数，我们将得到：$$ g(z) = \frac{1}{1+e^{-\theta^Tx}}</script><p>激活函数的图像：</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_2.png" alt="激活函数图像"></p><p>关于激活函数的说明：</p><ul><li>因为我们最终得到的是介于(0,1)之间的数值，其代表的是某样本最终结果是正例的概率。</li></ul><p><strong>例子</strong>:</p><p>如果$ x = \left[ \begin{matrix} x<em>0\x_1\…\x_n \end{matrix} \right]$得到的$ g</em>\theta = 0.7 $表示有70%的概率此样例的最终预测值为正例。</p><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><blockquote><p>决策边界可以让我们更好的理解逻辑回归的原理</p></blockquote><ul><li><p>由上述定义，我们知道当$ h<em>\theta(x) $&gt;0时，我们便预测为正例。$ h</em>\theta(x) $&lt;0时我们便预测为负例。</p></li><li><p>由激活函数的处理以及我们设定的阈值0.5，我们知道：</p></li></ul><p>$ g(z) &lt;0.5$时我们预测为0，反之则为1。</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_2.png" alt="决策边界图"></p><blockquote><p>注：$z = h_\theta(x)=\theta^Tx$</p><p>如图所示，当z的值非常大时g(z)将会趋向于无穷；当z的值非常小时g(z)将会趋近于0。</p></blockquote><p><strong>例子</strong>：</p><p>设$ h_\theta(x)= g(\theta_0+\theta_1x_1+\theta_1x_2)$是我们的假设函数</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_3.png" alt="决策边界例图"></p><p>假设我们拟合的参数为：$ \theta = \left[ \begin{matrix} -3\1\1 \end{matrix} \right] $,则有$ z = -3 + x<em>1 + x_2$,根据如上定义当$ h</em>\theta(x) $&gt;0时，我们便预测为正例。$ h_\theta(x) $&lt;0时我们便预测为负例。决策边界即为$ x_1+x_2 = 3 $,当我们画出该直线时我么可以看出其将正负例很好的分割了。</p><p>在本例中$ x_1+x_2 = 3 $就为决策边界。</p><blockquote><p>注意：在实际解决问题的过程中，由于我们需要拟合很多不同的数据集，而且我们也有可能遇到需要进行合并特征的情况，我们也会使用多项式拟合数据，会得到很多不同的决策边界，例如：圆，椭圆等。</p></blockquote><p><strong>例图</strong>：</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_4.png" alt="决策边界例图"></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><blockquote><p>为了确定我们在逻辑回归中的参数，我们在逻辑回归中也需要一个代价函数来进行参数的选择。</p></blockquote><p>在以前的问题中，我们为线性回归定义了线性回归的代价函数：</p><p>$ J(\theta) = \frac{1}{2m}\sum<em>{i=1}^{m}(h</em>\theta(x^{(i)})-y^{(i)})^2 $</p><p>但是在逻辑回归中使用此函数将使得$J(\theta)$的图像，如下图</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_5.png" alt="代价函数图"></p><p>图中情况很难使用一种行之有效的方式进行最小化代价函数，所以我们选择另一种代价函数。</p><p><strong>对数损失函数</strong>：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y^{(i)})</script><p>$ Cost(h<em>\theta(x^{(i)}),y^{(i)}) = -log(h</em>\theta(x))     $           if  y=1</p><p>$ Cost(h<em>\theta(x^{(i)}),y^{(i)}) = -log(1-h</em>\theta(x))$    if  y=0</p><p><strong>对数损失函数的原理</strong>：</p><blockquote><p>注意：上文我们提到通过对本来的输出值做激活函数的处理所以我们最终的输出值∈(0,1)</p></blockquote><p>对数损失函数的图像如下所示：</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_6.png" alt="对数损失函数"></p><p>在上图中，我们看出当实际的y值为1时，h(x)的输出结果约靠近1，J（θ）的值越小，即惩罚越小。</p><p><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_7.png" alt="对数损失函数"></p><p>在上图中，我们看出当实际的y值为0时，h(x)的输出结果约靠近0，J（θ）的值越小，即惩罚越小。</p><p>所以我们最终的目标依然是，找到一种方法确定θ使得损失函数尽量的减小。</p><h2 id="代价函数地简写形式"><a href="#代价函数地简写形式" class="headerlink" title="代价函数地简写形式"></a>代价函数地简写形式</h2><p>为让代价函数简写成一个式子，我们提出一种简写代价函数的方法：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{m}\sum_{i=1}^{m}Cost(h_\theta(x^{(i)}),y^{(i)}) = -\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}log(h_\theta(x)+(1-y^{(i)})log(1-(h_\theta(x))]</script><blockquote><p>当y为1时，括号内第二项为零，当y为0时，括号内第一项为0。</p></blockquote><p>在逻辑回归中，我们亦可以采用之前线性回归的梯度下降算法进行参数优化，不同点只是梯度下降中的$ h_\theta(x) $发生了变化。</p><h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p>除了梯度下降外，还有一些更优的最小化代价函数的方法，我们只需要计算出代价函数和偏导数传入算法中，我们就能获得参数的最优解。这类算法被称为<strong>最优化算法</strong>：</p><p>最优化算法的例子：</p><ul><li>梯度下降算法</li><li>共轭梯度算法</li><li>牛顿法和拟牛顿法<ul><li>DFP算法</li><li>局部优化算法（BFGS）</li><li>有限内存局部优化法（L_BFGS）</li></ul></li><li>拉格朗日数乘法</li></ul><p>最优算法将会很复杂，但是不需要我们选择学习速率α，我们在使用时又是并不需要完全理解内部逻辑，有很多代码库对诸多算法进行了封装供我们使用。</p><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>多分类问题例子：</p><p>对天气进行预测，预测晴天还是阴天或者下雨。</p><p>解决多分类问题的一个方法就是把它认为是多个二分类问题，称为<strong>One-vs-all</strong>：<br><img src="/2021/11/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_8.png" alt="多分类问题图"></p><p>如图所示，我们为每一个类别都进行逻辑回归，得到三个模型，每个模型值判断是否为第i类。</p><blockquote><p>k表示一共有k类需要我们进行逻辑回归。</p></blockquote><p>在多分类问题中，我们输出的结果不再是一个数值，而是一个k阶向量。最终输出的向量值代表了是第i类的可能性。</p><p>最终我们观察哪一个类别的可能性最高，然后作为我们最终的预测值。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第四章</title>
      <link href="/2021/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2021/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="多特征"><a href="#多特征" class="headerlink" title="多特征"></a>多特征</h2><ul><li>在解决实际问题的时候，通常会有很多描述不同性质的特征。例如在房屋预测问题上，房屋的年限，卧室的个数等。</li><li><p>多变量假设函数h表示为：$ h_\theta(x) = \theta_0 + \theta_1x_1+…+\theta_nx_n $</p></li><li><p>为了表示方便我们为$ \theta_0 $也添加一个变量$ x_0 $并且使其一直为1，那么多特征的线性回归方程可y引入线性代数表示为：</p></li></ul><script type="math/tex; mode=display">h_\theta(x) =[\theta_0,\theta_1...\theta_n] \left[ \begin{matrix} x_0\\x_1\\...\\x_n \end{matrix} \right]=\theta^Tx</script><blockquote><p>n:特征总数</p><p>$ x^{(i)} $:代表样本矩阵中第i行，也就是第i个训练实例。</p><p>$ x^{(i)}_{j} $:代表样本矩阵第i行第j列，也就是第i个实例的第j个向量的值。</p></blockquote><h2 id="多变量梯度下降"><a href="#多变量梯度下降" class="headerlink" title="多变量梯度下降"></a>多变量梯度下降</h2><blockquote><p>多变量梯度下降和单变量梯度下降类似，在多变量梯度下降中，我们的目标就是不断更新n个θ的值。</p></blockquote><p><strong>多变量梯度下降展开式：</strong></p><p><img src="/2021/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/ch4_1.png" alt="多变量梯度下降公式"></p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><ul><li><p>进行梯度下降时，特征值的取值范围有可能会有不同，这会影响代价函数收敛的速度。</p></li><li><p>为了优化梯度下降的速率我们将会使用<strong>特征缩放</strong>，使得各特征取值尽量一致。</p></li><li><p>均值归一化：</p><p>$ x_i:=\frac{x_i-average(x)}{max(x)-min(x)} $</p></li></ul><h2 id="学习速率"><a href="#学习速率" class="headerlink" title="学习速率"></a>学习速率</h2><p>首先介绍两种确定函数是否收敛的方法以及特点：</p><ul><li><p>多次迭代收敛法：通过绘制代价函数关于迭代次数的图像，可视化梯度下降的过程。</p><p><img src="/2021/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/ch4_2.png" alt="学习速率图"></p></li></ul><blockquote><p>横轴表示运行梯度下降的次数，纵轴表示运行相对于横轴次数的 J(θ) ，我们可以观察其曲线的状态来判断是否收敛，以及迭代次数和α的取值。</p></blockquote><p><img src="/2021/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/ch4_3.png" alt="学习速率图"></p><blockquote><p>当图像波动时，证明选择的速率过大，导致工作不正常。</p><p>当图像很平稳时，证明选择的速率过小，导致梯度下降缓慢。</p></blockquote><ul><li>特点：<ul><li>无法确定需要多少次迭代</li><li>较容易绘制关于迭代次数的图像</li><li>根据图像易预测所需要的迭代次数</li></ul></li><li>自动化检测收敛法：选择一个阈值，当J(θ)小于这个值的时候就判定已经收敛</li><li>特点：<ul><li>不易选择阈值</li><li>代价函数接近直线时无法确定收敛情况</li></ul></li></ul><h2 id="特征和多项式回归"><a href="#特征和多项式回归" class="headerlink" title="特征和多项式回归"></a>特征和多项式回归</h2><ul><li><p>在选取特征时，有时我们可以进行人为合并来为训练模型提供便利。</p></li><li><p>线性回归只能以直线进行拟合数据，有时也需要曲线来拟合数据，即多项式回归。</p><p><img src="/2021/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/ch4_4.png" alt="多项式回归图"></p><p><strong>注意</strong>：进行多项式回归一定要进行特征缩放，因为有指数的存在所以自变量的范围会进一步扩大。</p></li></ul><h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><p>对于<strong>线性方程</strong>还有一种方法来解决问题就是<strong>正规方程</strong>。</p><p>正规方程法，即令偏导数为0，通过解析函数的方式直接计算出参数向量的值。</p><blockquote><p>本质上就是根据当导数的值为0时，函数获得最小值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书-第三章-学习笔记</title>
      <link href="/2021/11/22/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/22/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>笔记的前一部分主要是对机器学习预备知识的概括，包括机器学习的定义/术语、学习器性能的评估/度量以及比较，本篇之后将主要对具体的学习算法进行理解总结，本篇则主要是第3章的内容—线性模型。</p><h1 id="3、线性模型"><a href="#3、线性模型" class="headerlink" title="3、线性模型"></a><strong>3、线性模型</strong></h1><p>谈及线性模型，其实我们很早就已经与它打过交道，还记得高中数学必修3课本中那个顽皮的“最小二乘法”吗？这就是线性模型的经典算法之一：根据给定的（x，y）点对，求出一条与这些点拟合效果最好的直线y=ax+b，之前我们利用下面的公式便可以计算出拟合直线的系数a,b（3.1中给出了具体的计算过程），从而对于一个新的x，可以预测它所对应的y值。前面我们提到：在机器学习的术语中，当预测值为连续值时，称为“回归问题”，离散值时为“分类问题”。本篇先从线性回归任务开始，接着讨论分类和多分类问题。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b068e48.png" alt="1.png"></p><h2 id="3-1-线性回归"><a href="#3-1-线性回归" class="headerlink" title="3.1 线性回归"></a><strong>3.1 线性回归</strong></h2><p>线性回归问题就是试图学到一个线性模型尽可能准确地预测新样本的输出值，例如：通过历年的人口数据预测2017年人口数量。在这类问题中，往往我们会先得到一系列的有标记数据，例如：2000—&gt;13亿…2016—&gt;15亿，这时输入的属性只有一个，即年份；也有输入多属性的情形，假设我们预测一个人的收入，这时输入的属性值就不止一个了，例如：（学历，年龄，性别，颜值，身高，体重）—&gt;15k。</p><p>有时这些输入的属性值并不能直接被我们的学习模型所用，需要进行相应的处理，对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；对于离散值的属性，可作下面的处理：</p><ul><li><p>若属性值之间存在“序关系”，则可以将其转化为连续值，例如：身高属性分为“高”“中等”“矮”，可转化为数值：{1， 0.5， 0}。</p></li><li><p>若属性值之间不存在“序关系”，则通常将其转化为向量的形式，例如：性别属性分为“男”“女”，可转化为二维向量：{（1，0），（0，1）}。</p></li></ul><p>（1）当输入属性只有一个的时候，就是最简单的情形，也就是我们高中时最熟悉的“最小二乘法”（Euclidean distance），首先计算出每个样本预测值与真实值之间的误差并求和，通过最小化均方误差MSE，使用求偏导等于零的方法计算出拟合直线y=wx+b的两个参数w和b，计算过程如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0ccec4.png" alt="2.png"></p><p>（2）当输入属性有多个的时候，例如对于一个样本有d个属性{（x1,x2…xd）,y}，则y=wx+b需要写成：</p><p><img src="https://i.loli.net/2018/10/17/5bc72567b8bcd.png" alt="0.png"></p><p>通常对于多元问题，常常使用矩阵的形式来表示数据。在本问题中，将具有m个样本的数据集表示成矩阵X，将系数w与b合并成一个列向量，这样每个样本的预测值以及所有样本的均方误差最小化就可以写成下面的形式：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0ad8f7.png" alt="3.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b0af652.png" alt="4.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b090543.png" alt="5.png"></p><p>同样地，我们使用最小二乘法对w和b进行估计，令均方误差的求导等于0，需要注意的是，当一个矩阵的行列式不等于0时，我们才可能对其求逆，因此对于下式，我们需要考虑矩阵（X的转置*X）的行列式是否为0，若不为0，则可以求出其解，若为0，则需要使用其它的方法进行计算，书中提到了引入正则化，此处不进行深入。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0cde33.png" alt="6.png"></p><p>另一方面，有时像上面这种原始的线性回归可能并不能满足需求，例如：y值并不是线性变化，而是在指数尺度上变化。这时我们可以采用线性模型来逼近y的衍生物，例如lny，这时衍生的线性模型如下所示，实际上就是相当于将指数曲线投影在一条直线上，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b103cbf.png" alt="7.png"></p><p>更一般地，考虑所有y的衍生物的情形，就得到了“广义的线性模型”（generalized linear model），其中，g（*）称为联系函数（link function）。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0a2841.png" alt="8.png"></p><h2 id="3-2-线性几率回归"><a href="#3-2-线性几率回归" class="headerlink" title="3.2 线性几率回归"></a><strong>3.2 线性几率回归</strong></h2><p>回归就是通过输入的属性值得到一个预测值，利用上述广义线性模型的特征，是否可以通过一个联系函数，将预测值转化为离散值从而进行分类呢？线性几率回归正是研究这样的问题。对数几率引入了一个对数几率函数（logistic function）,将预测值投影到0-1之间，从而将线性回归问题转化为二分类问题。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0c7748.png" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b0a655d.png" alt="10.png"></p><p>若将y看做样本为正例的概率，（1-y）看做样本为反例的概率，则上式实际上使用线性回归模型的预测结果器逼近真实标记的对数几率。因此这个模型称为“对数几率回归”（logistic regression），也有一些书籍称之为“逻辑回归”。下面使用最大似然估计的方法来计算出w和b两个参数的取值，下面只列出求解的思路，不列出具体的计算过程。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b824f0c.png" alt="11.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc723b817961.png" alt="12.png"></p><h2 id="3-3-线性判别分析"><a href="#3-3-线性判别分析" class="headerlink" title="3.3 线性判别分析"></a><strong>3.3 线性判别分析</strong></h2><p>线性判别分析（Linear Discriminant Analysis，简称LDA）,其基本思想是：将训练样本投影到一条直线上，使得同类的样例尽可能近，不同类的样例尽可能远。如图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc723b863ebb.png" alt="13.png"><img src="https://i.loli.net/2018/10/17/5bc723b85bfa9.png" alt="14.png"></p><p>想让同类样本点的投影点尽可能接近，不同类样本点投影之间尽可能远，即：让各类的协方差之和尽可能小，不用类之间中心的距离尽可能大。基于这样的考虑，LDA定义了两个散度矩阵。</p><ul><li>类内散度矩阵（within-class scatter matrix）</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b8156e1.png" alt="15.png"></p><ul><li>类间散度矩阵(between-class scaltter matrix)</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b7e9db3.png" alt="16.png"></p><p>因此得到了LDA的最大化目标：“广义瑞利商”（generalized Rayleigh quotient）。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b7e8a61.png" alt="17.png"></p><p>从而分类问题转化为最优化求解w的问题，当求解出w后，对新的样本进行分类时，只需将该样本点投影到这条直线上，根据与各个类别的中心值进行比较，从而判定出新样本与哪个类别距离最近。求解w的方法如下所示，使用的方法为λ乘子。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b83d5e0.png" alt="18.png"></p><p>若将w看做一个投影矩阵，类似PCA的思想，则LDA可将样本投影到N-1维空间（N为类簇数），投影的过程使用了类别信息（标记信息），因此LDA也常被视为一种经典的监督降维技术。<br>​             </p><h2 id="3-4-多分类学习"><a href="#3-4-多分类学习" class="headerlink" title="3.4 多分类学习"></a><strong>3.4 多分类学习</strong></h2><p>现实中我们经常遇到不只两个类别的分类问题，即多分类问题，在这种情形下，我们常常运用“拆分”的策略，通过多个二分类学习器来解决多分类问题，即将多分类问题拆解为多个二分类问题，训练出多个二分类学习器，最后将多个分类结果进行集成得出结论。最为经典的拆分策略有三种：“一对一”（OvO）、“一对其余”（OvR）和“多对多”（MvM），核心思想与示意图如下所示。</p><ul><li><p>OvO：给定数据集D，假定其中有N个真实类别，将这N个类别进行两两配对（一个正类/一个反类），从而产生N（N-1）/2个二分类学习器，在测试阶段，将新样本放入所有的二分类学习器中测试，得出N（N-1）个结果，最终通过投票产生最终的分类结果。</p></li><li><p>OvM：给定数据集D，假定其中有N个真实类别，每次取出一个类作为正类，剩余的所有类别作为一个新的反类，从而产生N个二分类学习器，在测试阶段，得出N个结果，若仅有一个学习器预测为正类，则对应的类标作为最终分类结果。</p></li><li><p>MvM：给定数据集D，假定其中有N个真实类别，每次取若干个类作为正类，若干个类作为反类（通过ECOC码给出，编码），若进行了M次划分，则生成了M个二分类学习器，在测试阶段（解码），得出M个结果组成一个新的码，最终通过计算海明/欧式距离选择距离最小的类别作为最终分类结果。</p></li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b862bfb.png" alt="19.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc723b8300d5.png" alt="20.png"></p><h2 id="3-5-类别不平衡问题"><a href="#3-5-类别不平衡问题" class="headerlink" title="3.5 类别不平衡问题"></a><strong>3.5 类别不平衡问题</strong></h2><p>类别不平衡（class-imbanlance）就是指分类问题中不同类别的训练样本相差悬殊的情况，例如正例有900个，而反例只有100个，这个时候我们就需要进行相应的处理来平衡这个问题。常见的做法有三种：</p><ol><li>在训练样本较多的类别中进行“欠采样”（undersampling）,比如从正例中采出100个，常见的算法有：EasyEnsemble。</li><li>在训练样本较少的类别中进行“过采样”（oversampling）,例如通过对反例中的数据进行插值，来产生额外的反例，常见的算法有SMOTE。</li><li>直接基于原数据集进行学习，对预测值进行“再缩放”处理。其中再缩放也是代价敏感学习的基础。<img src="https://i.loli.net/2018/10/17/5bc726fe87ae2.png" alt="21.png"></li></ol><p>​<br>​      </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第二章</title>
      <link href="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="房价预测（典型的监督学习中回归问题的例子）"><a href="#房价预测（典型的监督学习中回归问题的例子）" class="headerlink" title="房价预测（典型的监督学习中回归问题的例子）"></a>房价预测（典型的监督学习中回归问题的例子）</h2><ul><li>横轴为不同的房屋面积，纵轴是房屋的出售价格。</li></ul><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_1.png" alt="房价回归图"></p><h2 id="监督学习的基本工作模式"><a href="#监督学习的基本工作模式" class="headerlink" title="监督学习的基本工作模式"></a><strong>监督学习的基本工作模式</strong></h2><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_2.png" alt="监督学习基本工作模式"></p><ul><li>把训练集中的数据交给学习算法。</li><li>学习算法拟合训练集中的数据并输出一个函数用h表示。</li><li>h根据输入的x输出对应的预测y值，可以说h是x到y的一个映射。</li></ul><h2 id="单变量线性回归表达式"><a href="#单变量线性回归表达式" class="headerlink" title="单变量线性回归表达式"></a>单变量线性回归表达式</h2><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_3.png" alt="单变量线性回归表达式"></p><h1 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h1><blockquote><p>损失函数：计算单个样本的误差。<br>代价函数：计算整个训练集所有损失函数之和的平均值</p></blockquote><ul><li>我们要根据数据集拟合一个函数求解一个预测结果h最接近实际结果y时参数的取值，则可以表达为如下式子的最小值：</li></ul><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_4.png" alt="代价函数式子图"></p><ul><li>图中蓝色部分就是我们最终预测和实际结果的误差。</li></ul><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_5.png" alt="误差结果例图"></p><p><strong>根据上部分我们可以定义：</strong></p><ul><li><p>假设函数：$ h_\theta(x) = \theta_0 + \theta_1x. $</p></li><li><p>参数：$ \theta_0,\theta_1 $</p></li><li><p>代价函数：$ J(\theta<em>0,\theta_1) = \frac{1}{2m}\sum</em>{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 $</p></li><li><p>目标：最小化 $ J(\theta_0,\theta_1)$</p><p>图中将展示代价函数的工作原理：</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_6.png" alt="代价函数工作原理"></p><p>右图中随着$ \theta $的变化，$ J(\theta_0,\theta_1) $取得了最小值，相对于左侧函数来说就是h拟合的最好的情况。</p><blockquote><p>当参数很多时，代价函数的工作过程讲在多维上进行，此处略。</p></blockquote><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_7.png" alt="二维代价函数图"></p></li></ul><h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><p>在特征数很多的时候，我们需要一种方法来让计算机自动化找出最好拟合数据的函数h,换句话说也就是取到代价函数最小值时的$  \theta$，即<strong>梯度下降算法</strong>。</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_8.png" alt="梯度下降原理图"></p><p>梯度下降的原理：</p><ul><li>开始时随计选择一个参数组合，计算代价函数，寻找下一组能使大家函数下降的最多的组合，最后便能找到一个最小值，但此时的最小值只是<strong>局部最小值</strong>。</li><li>我们还需要选择不同的初始参数组合做对比来做相对比较以用来找到相对最小值。我们并不能知道当前的最小值是不是<strong>全局最小值</strong>。</li></ul><p>梯度下降的公式:</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_9.png" alt="梯度下降公式"></p><blockquote><p>本质上可能就是不断地求θ的偏导数，然后不断地下降。</p></blockquote><ul><li>聚焦公式，其中的α表示了梯度下降的步长，决定每步走多少距离。</li><li>公式中的偏导数才是决定下降的方向的关键。</li></ul><p><strong>注意</strong>：在计算时要进行批量更新而不是分开更新，否则结果上会有很大的不确定。</p><h2 id="梯度下降的补充理解"><a href="#梯度下降的补充理解" class="headerlink" title="梯度下降的补充理解"></a>梯度下降的补充理解</h2><p>上部分提到α和偏导数分别代表步长和方向，下面做补充解释：</p><ul><li><p>为简化问题便于理解，此处只考虑单变量的梯度下降，我们此处考虑一个变量参数θ，梯度下降中θ的更新公式为：<br><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_10.png" alt="梯度下降公式"></p><blockquote><p>由于只考虑一个变量θ，此处的导数计算可以用d表示。</p></blockquote></li><li><p>如果当前θ的映射出的 J(θ)在最小值的右侧，由于导数的值又表示当前点的切线的斜率，所以此时求得的公式中的值为正，当减去了正值之后θ在图中的位置将会向左移动,反之公式中的值为负，当减去了负值之后θ在图中的位置将会向右移动，最终收敛到最小值。</p></li></ul><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_11.png" alt="梯度下降原理"></p><blockquote><p>图中只考虑了二维的情况，多维的情况原理也相同。</p></blockquote><ul><li><p>下面关注步长α的意义，对于α来讲我们需要一个合适的值才能使得梯度下降运行良好。</p></li><li><p>α过小算法下降效率将会很低下，需要很多步骤才能完成最终的梯度下降，需要很高的时间复杂度，如图所示：</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_12.png" alt="梯度下降原理"></p></li><li><p>α过大算法将会运行不正常，有可能在迭代的过程中最小值直接被跳过，如图所示：</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/ch2_13.png" alt="梯度下降原理"></p></li></ul><h2 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h2><p>线性回归模型</p><ul><li><p>$ h_\theta(x) = \theta_0 + \theta_1x. $</p></li><li><p>$ J(\theta<em>0,\theta_1) = \frac{1}{2m}\sum</em>{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 $</p></li></ul><blockquote><p> 在线性回归中，梯度下降只要把h带入就完成了，此处不再展示。</p></blockquote><p>由于线性函数的回归函数只有一个全局的最优解，线性回归函数求解最小值问题属于<strong>凸函数优化问题</strong>。</p><p>第三章部分主要是线性代数的复习，不再做记录。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习吴恩达-学习笔记-第一章</title>
      <link href="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><ul><li>在没有明确设置的情况下使得计算机具有学习能力的领域。 -Samuel(1959)</li><li>计算机程序从经验E中学习解决某一任务T进行某个度量P通过测量P在T上的表现因经验E而提高。 -Tom (1998)<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2></li><li>监督学习：在监督学习中，我们想要计算机预测“正确值”。<ul><li>回归问题：预测一组连续的值。</li><li>分类问题：预测离散的值。<h3 id="监督学习的例子"><a href="#监督学习的例子" class="headerlink" title="监督学习的例子"></a>监督学习的例子</h3></li></ul></li><li><p>利用监督学习预测房价（回归问题）</p><ul><li>大多数情况下会拟合一条直线来进行回归</li><li><p>但是有时候会选择不一样的曲线进行拟合效果更好</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/ch1_1.jpg" alt="回归问题例图"></p></li></ul></li><li><p>利用监督学习推测乳腺癌良性与否（分类问题）</p><ul><li><p>尝试推测出离散的结果</p><p><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/ch1_2.png" alt="分类问题例图"></p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2></li></ul></li><li>根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，称之为无监督学习。<ul><li>无监督学习里典型例子是聚类。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。<h3 id="无监督学习的例子"><a href="#无监督学习的例子" class="headerlink" title="无监督学习的例子"></a>无监督学习的例子</h3></li></ul></li><li>聚类问题<br><img src="/2021/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%90%B4%E6%81%A9%E8%BE%BE-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/ch1_3.png" alt="聚类问题例图"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书-第二章-学习笔记</title>
      <link href="/2021/11/22/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/22/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是对第二章剩余知识的理解，包括：性能度量、比较检验和偏差与方差。在上一篇中，我们解决了评估学习器泛化性能的方法，即用测试集的“测试误差”作为“泛化误差”的近似，当我们划分好训练/测试集后，那如何计算“测试误差”呢？这就是性能度量，例如：均方差，错误率等，即“测试误差”的一个评价标准。有了评估方法和性能度量，就可以计算出学习器的“测试误差”，但由于“测试误差”受到很多因素的影响，例如：算法随机性或测试集本身的选择，那如何对两个或多个学习器的性能度量结果做比较呢？这就是比较检验。最后偏差与方差是解释学习器泛化性能的一种重要工具。</p><p><strong>2.5 性能度量</strong></p><p>性能度量（performance measure）是衡量模型泛化能力的评价标准，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果。本节除2.5.1外，其它主要介绍分类模型的性能度量。</p><p><strong>2.5.1 最常见的性能度量</strong></p><p>在回归任务中，即预测连续值的问题，最常用的性能度量是“均方误差”（mean squared error）,很多的经典算法都是采用了MSE作为评价函数，想必大家都十分熟悉。</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf76276.png" alt="1.png"></p><p>在分类任务中，即预测离散值的问题，最常用的是错误率和精度，错误率是分类错误的样本数占样本总数的比例，精度则是分类正确的样本数占样本总数的比例，易知：错误率+精度=1。</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf4c704.png" alt="2.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71daf6fb84.png" alt="3.png"></p><p><strong>2.5.2 查准率/查全率/F1</strong></p><p>错误率和精度虽然常用，但不能满足所有的需求，例如：在推荐系统中，我们只关心推送给用户的内容用户是否感兴趣（即查准率），或者说所有用户感兴趣的内容我们推送出来了多少（即查全率）。因此，使用查准/查全率更适合描述这类问题。对于二分类问题，分类结果混淆矩阵与查准/查全率定义如下：</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf885a4.png" alt="4.png"></p><p>初次接触时，FN与FP很难正确的理解，按照惯性思维容易把FN理解成：False-&gt;Negtive，即将错的预测为错的，这样FN和TN就反了，后来找到一张图，描述得很详细，为方便理解，把这张图也贴在了下边：</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf871a6.png" alt="5.png"></p><p>正如天下没有免费的午餐，查准率和查全率是一对矛盾的度量。例如我们想让推送的内容尽可能用户全都感兴趣，那只能推送我们把握高的内容，这样就漏掉了一些用户感兴趣的内容，查全率就低了；如果想让用户感兴趣的内容都被推送，那只有将所有内容都推送上，宁可错杀一千，不可放过一个，这样查准率就很低了。</p><p>“P-R曲线”正是描述查准/查全率变化的曲线，P-R曲线定义如下：根据学习器的预测结果（一般为一个实值或概率）对测试样本进行排序，将最可能是“正例”的样本排在前面，最不可能是“正例”的排在后面，按此顺序逐个把样本作为“正例”进行预测，每次计算出当前的P值和R值，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc71dafc4411.png" alt="6.png"></p><p>P-R曲线如何评估呢？若一个学习器A的P-R曲线被另一个学习器B的P-R曲线完全包住，则称：B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了“平衡点”（Break-Event Point，简称BEP），即当P=R时的取值，平衡点的取值越高，性能更优。</p><p>P和R指标有时会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，即：</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf40ff6.png" alt="7.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71daf75407.png" alt="8.png"></p><p>特别地，当β=1时，也就是常见的F1度量，是P和R的调和平均，当F1较高时，模型的性能越好。</p><p><img src="https://i.loli.net/2018/10/17/5bc71daf20885.png" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71daf4b90a.png" alt="10.png"></p><p>有时候我们会有多个二分类混淆矩阵，例如：多次训练或者在多个数据集上训练，那么估算全局性能的方法有两种，分为宏观和微观。简单理解，宏观就是先算出每个混淆矩阵的P值和R值，然后取得平均P值macro-P和平均R值macro-R，在算出Fβ或F1，而微观则是计算出混淆矩阵的平均TP、FP、TN、FN，接着进行计算P、R，进而求出Fβ或F1。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed70230e.png" alt="11.png"></p><p><strong>2.5.3 ROC与AUC</strong></p><p>如上所述：学习器对测试样本的评估结果一般为一个实值或概率，设定一个阈值，大于阈值为正例，小于阈值为负例，因此这个实值的好坏直接决定了学习器的泛化性能，若将这些实值排序，则排序的好坏决定了学习器的性能高低。ROC曲线正是从这个角度出发来研究学习器的泛化性能，ROC曲线与P-R曲线十分类似，都是按照排序的顺序逐一按照正例预测，不同的是ROC曲线以“真正例率”（True Positive Rate，简称TPR）为横轴，纵轴为“假正例率”（False Positive Rate，简称FPR），ROC偏重研究基于测试样本评估值的排序好坏。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6bee91.png" alt="12.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71ed75cefe.png" alt="13.png"></p><p>简单分析图像，可以得知：当FN=0时，TN也必须0，反之也成立，我们可以画一个队列，试着使用不同的截断点（即阈值）去分割队列，来分析曲线的形状，（0,0）表示将所有的样本预测为负例，（1,1）则表示将所有的样本预测为正例，（0,1）表示正例全部出现在负例之前的理想情况，（1,0）则表示负例全部出现在正例之前的最差情况。限于篇幅，这里不再论述。</p><p>现实中的任务通常都是有限个测试样本，因此只能绘制出近似ROC曲线。绘制方法：首先根据测试样本的评估值对测试样本排序，接着按照以下规则进行绘制。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed740a24.png" alt="14.png"></p><p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。ROC曲线下的面积定义为AUC（Area Uder ROC Curve），不同于P-R的是，这里的AUC是可估算的，即AOC曲线下每一个小矩形的面积之和。易知：AUC越大，证明排序的质量越好，AUC为1时，证明所有正例排在了负例的前面，AUC为0时，所有的负例排在了正例的前面。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6e2c57.png" alt="15.png"></p><p><strong>2.5.4 代价敏感错误率与代价曲线</strong></p><p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病—&gt;有疾病只是增多了检查，但有疾病—&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6ed582.png" alt="16.png"></p><p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”的错误率（2.5.1节介绍）为：</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed70bebe.png" alt="17.png"></p><p>同样对于ROC曲线，在非均等错误代价下，演变成了“代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6e952e.png" alt="18.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc71ed6eee7b.png" alt="19.png"></p><p>代价曲线的绘制很简单：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC 曲线土的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc71ed716e0d.png" alt="20.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书-第一章-学习笔记</title>
      <link href="/2021/11/20/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/20/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>傍晚小街路面上沁出微雨后的湿润，和熙的细风吹来，抬头看看天边的晚霞，嗯，明天又是一个好天气。走到水果摊旁，挑了个根蒂蜷缩、敲起来声音浊响的青绿西瓜，一边满心期待着皮薄肉厚瓢甜的爽落感，一边愉快地想着，这学期狠下了工夫，基础概念弄得清清楚楚，算法作业也是信手拈来，这门课成绩一定差不了！哈哈，也希望自己这学期的machine learning课程取得一个好成绩！</p><h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><p>正如我们根据过去的经验来判断明天的天气，吃货们希望从购买经验中挑选一个好瓜，那能不能让计算机帮助人类来实现这个呢？机器学习正是这样的一门学科，人的“经验”对应计算机中的“数据”，让计算机来学习这些经验数据，生成一个算法模型，在面对新的情况中，计算机便能作出有效的判断，这便是机器学习。</p><p>另一本经典教材的作者Mitchell给出了一个形式化的定义，假设：</p><ul><li>P：计算机程序在某任务类T上的性能。</li><li>T：计算机程序希望实现的任务类。</li><li>E：表示经验，即历史的数据集。</li></ul><p>若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。</p><h2 id="机器学习的一些基本术语"><a href="#机器学习的一些基本术语" class="headerlink" title="机器学习的一些基本术语"></a>机器学习的一些基本术语</h2><p>假设我们收集了一批西瓜的数据，例如：（色泽=青绿;根蒂=蜷缩;敲声=浊响)， (色泽=乌黑;根蒂=稍蜷;敲声=沉闷)， (色泽=浅自;根蒂=硬挺;敲声=清脆)……每对括号内是一个西瓜的记录，定义：     </p><ul><li><p>所有记录的集合为：数据集。</p></li><li><p>每一条记录为：一个实例（instance）或样本（sample）。</p></li><li><p>例如：色泽或敲声，单个的特点为特征（feature）或属性（attribute）。</p></li><li><p>对于一条记录，如果在坐标轴上表示，每个西瓜都可以用坐标轴中的一个点表示，一个点也是一个向量，例如（青绿，蜷缩，浊响），即每个西瓜为：一个特征向量（feature vector）。</p></li><li><p>一个样本的特征数为：维数（dimensionality），该西瓜的例子维数为3，当维数非常大时，也就是现在说的“维数灾难”。</p><p> 计算机程序学习经验数据生成算法模型的过程中，每一条记录称为一个“训练样本”，同时在训练好模型后，我们希望使用新的样本来测试模型的效果，则每一个新的样本称为一个“测试样本”。定义：    </p></li><li><p>所有训练样本的集合为：训练集（trainning set），[特殊]。</p></li><li><p>所有测试样本的集合为：测试集（test set），[一般]。  </p></li><li><p>机器学习出来的模型适用于新样本的能力为：泛化能力（generalization），即从特殊到一般。</p><p> 西瓜的例子中，我们是想计算机通过学习西瓜的特征数据，训练出一个决策模型，来判断一个新的西瓜是否是好瓜。可以得知我们预测的是：西瓜是好是坏，即好瓜与差瓜两种，是离散值。同样地，也有通过历年的人口数据，来预测未来的人口数量，人口数量则是连续值。定义：    </p></li><li><p>预测值为离散值的问题为：分类（classification）。</p></li><li><p>预测值为连续值的问题为：回归（regression）。</p><p> 我们预测西瓜是否是好瓜的过程中，很明显对于训练集中的西瓜，我们事先已经知道了该瓜是否是好瓜，学习器通过学习这些好瓜或差瓜的特征，从而总结出规律，即训练集中的西瓜我们都做了标记，称为标记信息。但也有没有标记信息的情形，例如：我们想将一堆西瓜根据特征分成两个小堆，使得某一堆的西瓜尽可能相似，即都是好瓜或差瓜，对于这种问题，我们事先并不知道西瓜的好坏，样本没有标记信息。定义：    </p></li><li><p>训练数据有标记信息的学习任务为：监督学习（supervised learning），容易知道上面所描述的分类和回归都是监督学习的范畴。</p></li><li><p>训练数据没有标记信息的学习任务为：无监督学习（unsupervised learning），常见的有聚类和关联规则。</p></li></ul><h1 id="模型的评估与选择"><a href="#模型的评估与选择" class="headerlink" title="模型的评估与选择"></a>模型的评估与选择</h1><h2 id="误差与过拟合"><a href="#误差与过拟合" class="headerlink" title="误差与过拟合"></a>误差与过拟合</h2><p>我们将学习器对样本的实际预测结果与样本的真实值之间的差异成为：误差（error）。定义：    </p><ul><li>在训练集上的误差称为训练误差（training error）或经验误差（empirical error）。</li><li>在测试集上的误差称为测试误差（test error）。</li><li>学习器在所有新样本上的误差称为泛化误差（generalization error）。</li></ul><p>显然，我们希望得到的是在新样本上表现得很好的学习器，即泛化误差小的学习器。因此，我们应该让学习器尽可能地从训练集中学出普适性的“一般特征”，这样在遇到新样本时才能做出正确的判别。然而，当学习器把训练集学得“太好”的时候，即把一些训练样本的自身特点当做了普遍特征；同时也有学习能力不足的情况，即训练集的基本特征都没有学习出来。我们定义：</p><ul><li>学习能力过强，以至于把训练样本所包含的不太一般的特性都学到了，称为：过拟合（overfitting）。</li><li>学习能太差，训练样本的一般性质尚未学好，称为：欠拟合（underfitting）。</li></ul><p>可以得知：在过拟合问题中，训练误差十分小，但测试误差教大；在欠拟合问题中，训练误差和测试误差都比较大。目前，欠拟合问题比较容易克服，例如增加迭代次数等，但过拟合问题还没有十分好的解决方案，过拟合是机器学习面临的关键障碍。</p><p><img src="https://i.loli.net/2018/10/17/5bc7181172996.png" alt></p><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><p>在现实任务中，我们往往有多种算法可供选择，那么我们应该选择哪一个算法才是最适合的呢？如上所述，我们希望得到的是泛化误差小的学习器，理想的解决方案是对模型的泛化误差进行评估，然后选择泛化误差最小的那个学习器。但是，泛化误差指的是模型在所有新样本上的适用能力，我们无法直接获得泛化误差。</p><p>因此，通常我们采用一个“测试集”来测试学习器对新样本的判别能力，然后以“测试集”上的“测试误差”作为“泛化误差”的近似。显然：我们选取的测试集应尽可能与训练集互斥，下面用一个小故事来解释why：</p><p>假设老师出了10 道习题供同学们练习，考试时老师又用同样的这10道题作为试题，可能有的童鞋只会做这10 道题却能得高分，很明显：这个考试成绩并不能有效地反映出真实水平。回到我们的问题上来，我们希望得到泛化性能好的模型，好比希望同学们课程学得好并获得了对所学知识”举一反三”的能力；训练样本相当于给同学们练习的习题，测试过程则相当于考试。显然，若测试样本被用作训练了，则得到的将是过于”乐观”的估计结果。</p><h2 id="训练集与测试集的划分方法"><a href="#训练集与测试集的划分方法" class="headerlink" title="训练集与测试集的划分方法"></a>训练集与测试集的划分方法</h2><p>如上所述：我们希望用一个“测试集”的“测试误差”来作为“泛化误差”的近似，因此我们需要对初始数据集进行有效划分，划分出互斥的“训练集”和“测试集”。下面介绍几种常用的划分方法：</p><h3 id="留出法"><a href="#留出法" class="headerlink" title="留出法"></a>留出法</h3><p>将数据集D划分为两个互斥的集合，一个作为训练集S，一个作为测试集T，满足D=S∪T且S∩T=∅，常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。需要注意的是：训练/测试集的划分要尽可能保持数据分布的一致性，以避免由于分布的差异引入额外的偏差，常见的做法是采取分层抽样。同时，由于划分的随机性，单次的留出法结果往往不够稳定，一般要采用若干次随机划分，重复实验取平均值的做法。</p><h3 id="交叉验证法"><a href="#交叉验证法" class="headerlink" title="交叉验证法"></a>交叉验证法</h3><p>将数据集D划分为k个大小相同的互斥子集，满足D=D1∪D2∪…∪Dk，Di∩Dj=∅（i≠j），同样地尽可能保持数据分布的一致性，即采用分层抽样的方法获得这些子集。交叉验证法的思想是：每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，这样就有K种训练集/测试集划分的情况，从而可进行k次训练和测试，最终返回k次测试结果的均值。交叉验证法也称“k折交叉验证”，k最常用的取值是10，下图给出了10折交叉验证的示意图。</p><p><img src="https://i.loli.net/2018/10/17/5bc718115d224.png" alt></p><p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p><h3 id="自助法"><a href="#自助法" class="headerlink" title="自助法"></a>自助法</h3><p>我们希望评估的是用整个D训练出的模型。但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差。留一法受训练样本规模变化的影响较小，但计算复杂度又太高了。“自助法”正是解决了这样的问题。</p><p>自助法的基本思想是：给定包含m个样本的数据集D，每次随机从D 中挑选一个样本，将其拷贝放入D’，然后再将该样本放回初始数据集D 中，使得该样本在下次采样时仍有可能被采到。重复执行m 次，就可以得到了包含m个样本的数据集D’。可以得知在m次采样中，样本始终不被采到的概率取极限为：</p><p><img src="https://i.loli.net/2018/10/17/5bc71811246dd.png" alt></p><p>这样，通过自助采样，初始样本集D中大约有36.8%的样本没有出现在D’中，于是可以将D’作为训练集，D-D’作为测试集。自助法在数据集较小，难以有效划分训练集/测试集时很有用，但由于自助法产生的数据集（随机抽样）改变了初始数据集的分布，因此引入了估计偏差。在初始数据集足够时，留出法和交叉验证法更加常用。</p><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p><p>学习算法的很多参数是在实数范围内取值，因此，对每种参数取值都训练出模型来是不可行的。常用的做法是：对每个参数选定一个范围和步长λ，这样使得学习的过程变得可行。例如：假定算法有3 个参数，每个参数仅考虑5 个候选值，这样对每一组训练/测试集就有5<em>5</em>5= 125 个模型需考察，由此可见：拿下一个参数（即经验值）对于算法人员来说是有多么的happy。</p><p>最后需要注意的是：当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西瓜书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战-第二章-学习笔记</title>
      <link href="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><a href="https://github.com/ageron/handson-ml2">获取数据集和源码</a><blockquote><p>作者建议使用脚本获取即时的数据，但是由于本数据是静态的所以暂且不使用作者书写脚本的方法。</p></blockquote></li></ul><h1 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h1><h2 id="编写加载数据的函数"><a href="#编写加载数据的函数" class="headerlink" title="编写加载数据的函数"></a>编写加载数据的函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DATA_PATH = &quot;datasets\housing&quot;</span><br><span class="line">def load_data(path = DATA_PATH):</span><br><span class="line">    csv_path = os.path.join(path,&quot;housing.csv&quot;)</span><br><span class="line">    return pd.read_csv(csv_path)</span><br></pre></td></tr></table></figure><p><a href="https://note.youdao.com/"> os.path.join( ) 用法详解</a></p><h2 id="快速查看数据结构"><a href="#快速查看数据结构" class="headerlink" title="快速查看数据结构"></a>快速查看数据结构</h2><ul><li>首先使用 head() 方法来查看数据开头的几行，大概浏览数据的特征以及每个特征的基本数值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ch_2_1.jpg" alt="图片无法显示"><br><img src="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ch_2_1.jpg" class title="This is an test image"></p><ul><li>通过 info() 函数快速获得数据集的简单描述，主要是总行数以及每个属性类型非空值的数量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.info())</span><br></pre></td></tr></table></figure><p><img src="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ch_2_2.png" alt="图片无法显示"></p><ul><li>通过 value_counts() 方法查看有多少种分类存在。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[&#x27;ocean_proximity&#x27;].value_counts()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ch_2_3.png" alt="图片无法显示"></p><ul><li>通过 describe() 函数获得数值属性的摘要。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ch_2_4.png" alt="图片无法显示"></p><ul><li>通过绘制每个数值属性的直方图来了解数据类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data.hist(bins=50, figsize=(20,15))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ch_2_5.png" alt="图片无法显示"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习实战 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
